---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - pnpm-lock.yaml
  - vite.config.ts
  - tsconfig.json
  - eslint.config.ts
  - index.html
  - src/app.tsx
  - src/index.tsx
  - src/worker/worker.ts
  - src/worker/bridge.ts
  - src/types/messages.ts
  - wasm/core/Cargo.toml
  - wasm/core/src/lib.rs
  - public/icons/icon-192.png
  - public/icons/icon-512.png
  - public/icons/icon-maskable.png
autonomous: true
requirements:
  - TRST-01
  - TRST-07

must_haves:
  truths:
    - "Project builds successfully with `pnpm build` producing a valid dist/ output"
    - "Dev server starts with `pnpm dev` and serves a SolidJS page at localhost"
    - "ESLint runs and catches SolidJS reactivity violations (destructuring props)"
    - "WASM three-step build pipeline compiles Rust to .wasm and the Worker loads it"
    - "Web Worker initializes, loads WASM module, and responds to INIT message"
    - "Zero network calls are made by the application at runtime (service worker caches all assets)"
  artifacts:
    - path: "package.json"
      provides: "Project dependencies and build scripts"
      contains: "solid-js"
    - path: "vite.config.ts"
      provides: "Vite config with SolidJS, PWA, WASM plugins"
      contains: "VitePWA"
    - path: "eslint.config.ts"
      provides: "ESLint flat config with SolidJS plugin"
      contains: "eslint-plugin-solid"
    - path: "src/worker/worker.ts"
      provides: "Web Worker entry point with WASM init and message dispatch"
      contains: "onmessage"
    - path: "src/worker/bridge.ts"
      provides: "Main-thread Worker bridge with typed message dispatch"
      contains: "postMessage"
    - path: "wasm/core/Cargo.toml"
      provides: "Rust WASM crate configuration"
      contains: "wasm-bindgen"
    - path: "wasm/core/src/lib.rs"
      provides: "Minimal Rust WASM module with skeleton API"
      contains: "wasm_bindgen"
  key_links:
    - from: "src/worker/bridge.ts"
      to: "src/worker/worker.ts"
      via: "new Worker() constructor"
      pattern: "new Worker"
    - from: "src/worker/worker.ts"
      to: "wasm/core/src/lib.rs"
      via: "WASM init() import"
      pattern: "import init"
    - from: "src/app.tsx"
      to: "src/worker/bridge.ts"
      via: "Worker bridge import"
      pattern: "import.*bridge"
---

<objective>
Scaffold the BinderOS project: Vite + SolidJS + TypeScript + ESLint (solid plugin) + Zod, PWA configuration, three-step WASM build pipeline, and Web Worker bridge skeleton.

Purpose: Establish the foundational project structure that all subsequent plans build on. The ESLint SolidJS plugin must be configured before any component code is written (silent reactivity failures if missed). The Worker-owned WASM pattern must be established before any atom operations are wired up (retrofitting a Worker into direct-WASM-from-UI code is a near-complete rewrite).

Output: A building, linting, PWA-configured SolidJS project with a working WASM compilation pipeline and Worker communication bridge.
</objective>

<execution_context>
@C:/Users/patri/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/patri/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Vite + SolidJS + TypeScript project with ESLint, PWA, and WASM plugins</name>
  <files>
    package.json
    pnpm-lock.yaml
    vite.config.ts
    tsconfig.json
    eslint.config.ts
    index.html
    src/app.tsx
    src/index.tsx
    src/types/messages.ts
    public/icons/icon-192.png
    public/icons/icon-512.png
    public/icons/icon-maskable.png
  </files>
  <action>
Create the project from scratch (do NOT use a SolidJS template — configure manually for full control).

1. Initialize with `pnpm init` in the project root.

2. Install core dependencies:
   ```
   pnpm add solid-js @solidjs/router dexie zod solid-dexie dexie-export-import
   ```

3. Install dev dependencies:
   ```
   pnpm add -D vite vite-plugin-solid vite-plugin-pwa vite-plugin-wasm vite-plugin-top-level-await typescript eslint eslint-plugin-solid @typescript-eslint/eslint-plugin @typescript-eslint/parser vitest @solidjs/testing-library jsdom
   ```

4. Create `vite.config.ts` with plugins in this exact order: `solid()`, `wasm()`, `topLevelAwait()`, `VitePWA({...})`. Plugin order matters — vite-plugin-wasm must load before topLevelAwait. PWA config per RESEARCH.md Pattern 6:
   - registerType: 'autoUpdate'
   - manifest: name 'BinderOS', theme_color '#0d1117', background_color '#0d1117', display 'standalone', orientation 'any', start_url '/'
   - Icons array with 192, 512, and maskable variants
   - share_target: action '/share-target', method 'GET', params { title: 'title', text: 'text', url: 'url' }
   - workbox: globPatterns ['**/*.{js,css,html,wasm,png,svg,ico}']

5. Create `tsconfig.json` per RESEARCH.md code example: target ES2022, module ESNext, moduleResolution bundler, jsx preserve, jsxImportSource solid-js, strict true, noUncheckedIndexedAccess true, types ["vite-plugin-pwa/solid", "vite/client"], paths {"~/*": ["./src/*"]}.

6. Create `eslint.config.ts` using ESLint v9 flat config per RESEARCH.md Pattern 8: import solid from 'eslint-plugin-solid/configs/typescript', import tsParser, configure for **/*.{ts,tsx} files. This catches solid/reactivity, solid/no-destructure, solid/prefer-for, solid/no-innerhtml.

7. Create `index.html` with:
   - `<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">`
   - `<meta name="theme-color" content="#0d1117">`
   - `<link rel="manifest" href="/manifest.webmanifest">`
   - `<div id="root"></div>` and `<script type="module" src="/src/index.tsx"></script>`

8. Create `src/index.tsx` that calls `render(() => <App />, document.getElementById('root')!)`.

9. Create `src/app.tsx` with a minimal SolidJS component that displays "BinderOS" text. This is a placeholder — Plan 03 builds the real shell.

10. Create `src/types/messages.ts` with the Worker message protocol types:
    - `Command` discriminated union: `{ type: 'INIT' } | { type: 'CREATE_ATOM', payload: ... } | { type: 'UPDATE_ATOM', payload: ... } | { type: 'DELETE_ATOM', payload: ... }`
    - `Response` discriminated union: `{ type: 'READY', payload: ... } | { type: 'ATOM_CREATED', payload: ... } | { type: 'ATOM_UPDATED', payload: ... } | { type: 'ERROR', payload: { message: string } }`
    - Export both types. These will be refined in Plan 02 when atom types are defined.

11. Generate placeholder PWA icons (simple colored squares with "B" letter) as PNG files at public/icons/icon-192.png, public/icons/icon-512.png, and public/icons/icon-maskable.png. Use a script or create minimal valid PNG files. These are placeholders — real icons come later.

12. Add npm scripts to package.json:
    - "dev": "vite"
    - "build": "vite build"
    - "preview": "vite preview"
    - "lint": "eslint src/"
    - "build:wasm": (see Task 2 for the full command)
    - "test": "vitest run"

  </action>
  <verify>
Run these commands in sequence:
1. `pnpm install` completes without errors
2. `pnpm lint` runs without errors on src/ (should pass on the minimal app.tsx)
3. `pnpm build` produces dist/ directory with index.html, JS bundles, and manifest.webmanifest
4. `pnpm dev` starts dev server (check it responds at localhost with SolidJS content)
  </verify>
  <done>
Project scaffolded: `pnpm build` succeeds, `pnpm lint` passes, `pnpm dev` serves a SolidJS page, manifest.webmanifest exists in build output, ESLint SolidJS plugin is active and would catch `const { x } = props` violations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Set up Rust WASM three-step build pipeline and Web Worker bridge</name>
  <files>
    wasm/core/Cargo.toml
    wasm/core/src/lib.rs
    src/worker/worker.ts
    src/worker/bridge.ts
    package.json
  </files>
  <action>
1. Create `wasm/core/Cargo.toml` per RESEARCH.md code example:
   - name "binderos-core", edition "2021"
   - crate-type = ["cdylib"]
   - Dependencies: wasm-bindgen = "0.2.109", serde = { version = "1", features = ["derive"] }, serde-wasm-bindgen = "0.6", js-sys = "0.3"
   - [profile.release]: opt-level = "s", panic = "abort", lto = true

2. Create `wasm/core/src/lib.rs` with a minimal WASM module:
   - `use wasm_bindgen::prelude::*;`
   - A `BinderCore` struct with `#[wasm_bindgen]`
   - `BinderCore::new()` constructor
   - A `ping()` method that returns "pong" (smoke test for Worker communication)
   - A `version()` method that returns the crate version string
   - This is a skeleton — Phase 2 adds the real compute engine. Phase 1 only needs the Worker bridge to be functional.

3. Run the three-step WASM build pipeline:
   ```
   cargo build --target wasm32-unknown-unknown --release --manifest-path wasm/core/Cargo.toml
   wasm-bindgen --target web ./target/wasm32-unknown-unknown/release/binderos_core.wasm --out-dir ./src/wasm/pkg
   wasm-opt -Oz ./src/wasm/pkg/binderos_core_bg.wasm -o ./src/wasm/pkg/binderos_core_bg.wasm
   ```
   NOTE: Ensure `rustup target add wasm32-unknown-unknown` is available. If wasm-bindgen-cli is not installed, run `cargo install wasm-bindgen-cli --version 0.2.109`. If wasm-opt is not installed, run `cargo install wasm-opt` (or install binaryen). Adapt paths for Windows if needed (forward slashes should work in Git Bash).

4. Add the build:wasm script to package.json:
   ```
   "build:wasm": "cargo build --target wasm32-unknown-unknown --release --manifest-path wasm/core/Cargo.toml && wasm-bindgen --target web ./target/wasm32-unknown-unknown/release/binderos_core.wasm --out-dir ./src/wasm/pkg && wasm-opt -Oz ./src/wasm/pkg/binderos_core_bg.wasm -o ./src/wasm/pkg/binderos_core_bg.wasm"
   ```
   Also add a combined build: `"build:all": "pnpm build:wasm && pnpm build"`

5. Create `src/worker/worker.ts`:
   - Import init and BinderCore from '../wasm/pkg'
   - self.onmessage handler that dispatches on message type
   - On 'INIT': await init(), create BinderCore.new(), call self.postMessage({ type: 'READY', payload: { version: core.version() } })
   - On 'PING': call core.ping(), self.postMessage({ type: 'PONG', payload: result })
   - Wrap all handlers in try/catch, postMessage { type: 'ERROR', payload: { message: err.message } } on failure
   - Import Command and Response types from '../types/messages'

6. Create `src/worker/bridge.ts`:
   - Create worker instance: `new Worker(new URL('./worker.ts', import.meta.url), { type: 'module' })`
   - Export `dispatch(command: Command): void` that calls worker.postMessage(command)
   - Export `onMessage(handler: (response: Response) => void): void` that sets worker.onmessage
   - Export `initWorker(): Promise<Response>` that sends INIT and returns a promise resolved on READY response
   - All types imported from '../types/messages'

7. Update `src/app.tsx` to call `initWorker()` on mount (using `onMount` from SolidJS) and display the WASM version returned from the READY response. This proves the full chain works: App -> Bridge -> Worker -> WASM -> Worker -> Bridge -> App.

CRITICAL: Do not import WASM directly in any UI component. WASM lives exclusively inside the Worker. This is the foundational architectural pattern (RESEARCH.md Pattern 1).
  </action>
  <verify>
Run these commands in sequence:
1. `pnpm build:wasm` compiles Rust and produces files in src/wasm/pkg/ (*.wasm, *.js, *.d.ts)
2. `pnpm build` succeeds (Vite bundles the Worker and WASM correctly)
3. `pnpm dev` — open browser, check console: Worker should initialize and WASM version should display on page
4. `pnpm lint` still passes with no errors
  </verify>
  <done>
WASM pipeline functional: `pnpm build:wasm` produces valid .wasm output, Worker initializes WASM on INIT message and responds with READY, the main thread displays WASM version via the bridge, and no WASM imports exist outside the worker/ directory.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build:all` succeeds end-to-end (WASM compile + Vite build)
2. `pnpm lint` passes with zero errors
3. `pnpm dev` serves the app; browser shows BinderOS with WASM version
4. dist/ contains manifest.webmanifest with share_target configuration
5. No network calls observed in dev tools Network tab (after initial page load)
6. Worker communicates with main thread via typed messages
</verification>

<success_criteria>
- Vite + SolidJS + TypeScript project builds and serves correctly
- ESLint with SolidJS plugin configured and active (catches reactivity violations)
- PWA manifest generated with share target, icons, standalone display
- Rust WASM compiles via three-step pipeline (cargo -> wasm-bindgen-cli -> wasm-opt)
- Web Worker loads WASM and responds to INIT/PING messages
- Main thread bridge sends commands and receives typed responses
- Full chain proven: UI -> Bridge -> Worker -> WASM -> Worker -> Bridge -> UI
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
