---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/types/atoms.ts
  - src/types/sections.ts
  - src/types/changelog.ts
  - src/types/messages.ts
  - src/storage/db.ts
  - src/storage/write-queue.ts
  - src/storage/migrations/v1.ts
  - src/storage/export.ts
  - src/storage/changelog.ts
  - src/storage/persistence.ts
autonomous: true
requirements:
  - DATA-01
  - DATA-02
  - DATA-03
  - DATA-04
  - DATA-05
  - DATA-06
  - TRST-03
  - TRST-05
  - TRST-06
  - ORG-01
  - ORG-02

must_haves:
  truths:
    - "Atoms of all five types (task, fact, event, decision, insight) can be created and validated by Zod"
    - "Every atom has id, type, created_at, updated_at, links array, and status — enforced by schema"
    - "Untyped atoms are rejected by Zod validation (type field is mandatory)"
    - "Atom content is a string field that accepts Markdown"
    - "All atom writes go through Dexie.js with Zod validation at the boundary"
    - "Schema version is explicit (Dexie version 1) with upgrade path for future migrations"
    - "Every atom mutation appends a CRDT-compatible entry to the change log"
    - "Four stable sections (Projects, Areas, Resources, Archive) exist as seed data"
    - "Section items can be created, renamed, and archived within sections"
    - "Storage persistence is requested and grant status is stored in config"
  artifacts:
    - path: "src/types/atoms.ts"
      provides: "Zod schemas for five atom types + InboxItem + TypeScript types"
      contains: "AtomSchema"
    - path: "src/types/sections.ts"
      provides: "Section and SectionItem Zod schemas and types"
      contains: "SectionSchema"
    - path: "src/types/changelog.ts"
      provides: "MutationLogEntry type with CRDT fields (lamportClock, deviceId)"
      contains: "MutationLogEntry"
    - path: "src/storage/db.ts"
      provides: "Dexie database instance with all tables and indexes"
      contains: "BinderDB"
    - path: "src/storage/write-queue.ts"
      provides: "Debounced write queue (300ms) for batched IndexedDB transactions"
      contains: "WriteQueue"
    - path: "src/storage/changelog.ts"
      provides: "Functions to append mutation log entries with lamport clock"
      contains: "appendMutation"
    - path: "src/storage/persistence.ts"
      provides: "Storage persistence request and status check"
      contains: "initStoragePersistence"
  key_links:
    - from: "src/storage/db.ts"
      to: "src/types/atoms.ts"
      via: "Dexie table types reference Atom type"
      pattern: "Table<Atom"
    - from: "src/storage/write-queue.ts"
      to: "src/storage/db.ts"
      via: "Write queue flushes to Dexie transaction"
      pattern: "db\\.transaction"
    - from: "src/storage/changelog.ts"
      to: "src/types/changelog.ts"
      via: "Changelog functions create MutationLogEntry records"
      pattern: "MutationLogEntry"
    - from: "src/types/atoms.ts"
      to: "zod"
      via: "Zod schema definitions"
      pattern: "z\\.object|z\\.discriminatedUnion"
---

<objective>
Define the complete typed atom schema with Zod validation, set up Dexie.js IndexedDB persistence with write queue, implement CRDT-compatible change log, and establish the four stable sections.

Purpose: This plan creates the data layer that all UI and compute features depend on. Atoms are the fundamental unit of BinderOS. Without validated schemas and reliable persistence, nothing else works. The CRDT-compatible change log fields cost nothing now but save a painful migration when sync ships.

Output: Complete type system (atoms, sections, changelog, messages), Dexie database with all tables and indexes, write queue for batched IndexedDB writes, mutation logging, storage persistence flow, and export capability.
</objective>

<execution_context>
@C:/Users/patri/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/patri/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define Zod schemas for atoms, sections, changelog, and message protocol</name>
  <files>
    src/types/atoms.ts
    src/types/sections.ts
    src/types/changelog.ts
    src/types/messages.ts
  </files>
  <action>
1. Create `src/types/atoms.ts` per RESEARCH.md Pattern 3:
   - `AtomStatus` enum: 'open', 'in-progress', 'waiting', 'done', 'cancelled', 'archived'
   - `AtomType` enum: 'task', 'fact', 'event', 'decision', 'insight'
   - `AtomLink` object: targetId (uuid string), relationshipType (string, e.g. "belongs-to", "depends-on", "relates-to"), direction ('forward' | 'backward')
   - `BaseAtom` object: id (uuid), type (AtomType), content (string — Markdown), title (string), status (AtomStatus), links (AtomLink array), sectionId (optional uuid), sectionItemId (optional uuid), created_at (number — Unix ms), updated_at (number — Unix ms)
   - Type-specific extensions using discriminated union:
     - TaskAtom: extends BaseAtom with type literal 'task', dueDate (optional number), scheduledDate (optional number)
     - FactAtom: extends BaseAtom with type literal 'fact'
     - EventAtom: extends BaseAtom with type literal 'event', eventDate (optional number)
     - DecisionAtom: extends BaseAtom with type literal 'decision'
     - InsightAtom: extends BaseAtom with type literal 'insight'
   - `AtomSchema`: z.discriminatedUnion('type', [TaskAtom, FactAtom, EventAtom, DecisionAtom, InsightAtom])
   - `Atom` type: z.infer of AtomSchema
   - `InboxItemSchema`: BaseAtom with type as optional (not yet classified), plus `isInbox: z.literal(true)`. InboxItems can exist without a type — they must be classified before becoming full Atoms.
   - `InboxItem` type: z.infer of InboxItemSchema
   - `CreateAtomInput` schema: Omit id, created_at, updated_at from AtomSchema (these are generated server-side/worker-side)
   - Export all schemas and inferred types

   Per user decision: Links are typed edges with relationship types, directional (forward/backward), extensible. Type-aware link rules will be enforced later (Phase 2 compute or a validation function). For now, store the relationship type as a string.

2. Create `src/types/sections.ts`:
   - `SectionType` enum: 'projects', 'areas', 'resources', 'archive' (the four stable sections per ORG-01)
   - `SectionSchema`: id (uuid), name (string), type (SectionType), order (number), created_at (number)
   - `Section` type inferred from schema
   - `SectionItemSchema`: id (uuid), sectionId (uuid), name (string), description (string optional), archived (boolean, default false), created_at (number), updated_at (number)
   - `SectionItem` type inferred from schema
   - Export all schemas and types

3. Create `src/types/changelog.ts` per RESEARCH.md Pattern 4:
   - `MutationOperation` enum: 'create', 'update', 'delete', 'archive', 'link', 'unlink'
   - `MutationLogEntrySchema`: id (uuid), atomId (string), operation (MutationOperation), before (Atom | null — full snapshot before mutation, null for create), after (Atom | null — full snapshot after mutation, null for delete), timestamp (number — Unix ms), lamportClock (number — monotonic device counter), deviceId (string — UUID from localStorage)
   - `MutationLogEntry` type inferred from schema
   - Include `before` and `after` fields from day one for CRDT-compatible undo
   - Export schema and type

4. Update `src/types/messages.ts` (created in Plan 01) to use the real atom types:
   - Import Atom, InboxItem, CreateAtomInput from atoms.ts
   - Import Section, SectionItem from sections.ts
   - Refine Command union: INIT, CREATE_ATOM (payload: CreateAtomInput), UPDATE_ATOM (payload: { id: string, changes: Partial<Atom> }), DELETE_ATOM (payload: { id: string }), CREATE_INBOX_ITEM (payload: { content: string, title?: string }), CLASSIFY_INBOX_ITEM (payload: { id: string, type: AtomType, sectionItemId?: string }), CREATE_SECTION_ITEM (payload: { sectionId: string, name: string }), RENAME_SECTION_ITEM (payload: { id: string, name: string }), ARCHIVE_SECTION_ITEM (payload: { id: string }), EXPORT_DATA, REQUEST_PERSISTENCE, UNDO
   - Refine Response union: READY (payload with version, sections, atoms, inboxItems), STATE_UPDATE (payload with atoms, inboxItems, sections, sectionItems), ERROR (payload: { message: string, command?: string }), EXPORT_READY (payload: { blob: Blob }), PERSISTENCE_STATUS (payload: { granted: boolean })
   - Export all types
  </action>
  <verify>
1. `pnpm lint` passes with no errors on all type files
2. Create a quick verification: `npx tsx -e "import { AtomSchema } from './src/types/atoms'; console.log(AtomSchema.safeParse({ id: '550e8400-e29b-41d4-a716-446655440000', type: 'task', title: 'Test', content: '# Hello', status: 'open', links: [], created_at: Date.now(), updated_at: Date.now() }).success)"` should print `true`
3. AtomSchema.safeParse with missing type field should return `{ success: false }`
4. `pnpm build` succeeds (TypeScript compilation of all type files)
  </verify>
  <done>
All type definitions exist with Zod schemas: five atom types validated via discriminated union, InboxItem with optional type, Section with four stable types, MutationLogEntry with CRDT fields (lamportClock, deviceId, before/after snapshots), Worker message protocol with all command/response variants. TypeScript types are inferred from Zod schemas (single source of truth).
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Dexie database, write queue, change log, persistence check, and export</name>
  <files>
    src/storage/db.ts
    src/storage/write-queue.ts
    src/storage/migrations/v1.ts
    src/storage/changelog.ts
    src/storage/export.ts
    src/storage/persistence.ts
  </files>
  <action>
1. Create `src/storage/db.ts` per RESEARCH.md Pattern 9:
   - Class BinderDB extends Dexie with typed tables:
     - atoms: Table of Atom, keyed by string
     - inbox: Table of InboxItem, keyed by string
     - changelog: Table of MutationLogEntry, keyed by string
     - sections: Table of Section, keyed by string
     - sectionItems: Table of SectionItem, keyed by string
     - config: Table of { key: string; value: unknown }, keyed by string
   - Version 1 stores definition:
     - atoms: '&id, type, status, sectionId, sectionItemId, updated_at, *links'
     - inbox: '&id, created_at'
     - changelog: '&id, atomId, timestamp, lamportClock'
     - sections: '&id, type'
     - sectionItems: '&id, sectionId, name, archived'
     - config: '&key'
   - NOTE: `*links` is a multi-entry index on the links array (RESEARCH.md Pitfall 6). This is critical for querying "all atoms that link to atom X" without loading everything.
   - Export singleton `db` instance.
   - After db creation, call `db.on('populate')` to seed the four stable sections (Projects, Areas, Resources, Archive) with fixed UUIDs and order 1-4. This runs only on first database creation.

2. Create `src/storage/migrations/v1.ts`:
   - Export the seed data function that populates the four default sections
   - This is called from db.on('populate') in db.ts
   - Use deterministic UUIDs for the four sections (e.g., derive from section name via a simple hash) so they're consistent across fresh installs

3. Create `src/storage/write-queue.ts` per RESEARCH.md Pattern 2:
   - WriteQueue class with:
     - Private queue array of write operations (each is `() => Promise<void>`)
     - Private timer for debounce
     - DEBOUNCE_MS = 300 (configurable)
     - `enqueue(op: WriteOperation): void` — pushes op, clears existing timer, sets new timer for flush
     - `flush(): Promise<void>` — if queue empty return; splice all ops; wrap in `db.transaction('rw', db.atoms, db.changelog, db.inbox, db.sections, db.sectionItems, async () => { for (const op of ops) await op(); })`
     - `flushImmediate(): Promise<void>` — force flush without waiting for debounce (used for critical writes like export)
   - Export singleton `writeQueue` instance

4. Create `src/storage/changelog.ts`:
   - `getDeviceId(): string` — reads from localStorage('binderos-device-id'); if not found, generates UUID and stores it. This is the CRDT device identifier.
   - `getLamportClock(): number` — reads from a module-level counter initialized from the max lamportClock in the changelog table on startup. Monotonically increments.
   - `initLamportClock(): Promise<void>` — reads max lamportClock from db.changelog, sets the module counter. Must be called once on app/worker init.
   - `appendMutation(atomId: string, operation: MutationOperation, before: Atom | null, after: Atom | null): MutationLogEntry` — creates entry with new UUID, current timestamp, incremented lamport clock, device ID. Returns the entry (caller adds to writeQueue).
   - Export all functions

5. Create `src/storage/export.ts` per RESEARCH.md Pattern 10:
   - `exportAllData(): Promise<void>` — uses `exportDB` from dexie-export-import to create a Blob, triggers download via programmatic anchor click. Filename: `binderos-backup-YYYY-MM-DD.json`.
   - `exportAsMarkdown(): Promise<void>` — reads all atoms from db, formats each as a Markdown document (# Title, type, status, content, links, timestamps), concatenates into a single .md file, triggers download. This provides a human-readable export alongside the machine-readable JSON.
   - Export both functions

6. Create `src/storage/persistence.ts` per RESEARCH.md Pattern 5:
   - `initStoragePersistence(): Promise<{ supported: boolean; granted: boolean }>` — checks navigator.storage.persist support, calls persisted() first (may already be granted), if not calls persist(), returns result.
   - `checkPersistenceStatus(): Promise<boolean>` — calls navigator.storage.persisted() to get current status.
   - `getStorageEstimate(): Promise<{ usage: number; quota: number } | null>` — calls navigator.storage.estimate() to get storage usage info for the status bar.
   - Export all functions

CRITICAL: All write operations MUST go through the writeQueue. No direct db.atoms.put() calls from outside the storage layer. Zod validation must happen BEFORE enqueuing (validate at the boundary, not inside the transaction).
  </action>
  <verify>
1. `pnpm lint` passes on all storage files
2. `pnpm build` succeeds (all imports resolve, types check)
3. Write a quick integration check: open the app in browser, check IndexedDB in DevTools — BinderOS database should exist with tables: atoms, inbox, changelog, sections, sectionItems, config
4. Verify four sections (Projects, Areas, Resources, Archive) exist as seed data in the sections table
5. Verify deviceId is stored in localStorage under 'binderos-device-id'
  </verify>
  <done>
Storage layer complete: Dexie database with all tables and multi-entry indexes, write queue with 300ms debounce batching, CRDT-compatible change log with lamport clock and device ID, storage persistence check, JSON and Markdown export functions. Four stable sections seeded on first run. All types are Zod-validated at the write boundary.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` succeeds with all type and storage files
2. `pnpm lint` passes across all new files
3. Zod schema validates correct atoms and rejects invalid ones (missing type, wrong status, etc.)
4. Dexie database creates with correct tables and indexes on first load
5. Four sections seeded: Projects, Areas, Resources, Archive
6. Write queue batches multiple operations into a single transaction
7. Change log entries include lamportClock, deviceId, before/after snapshots
8. Storage persistence requested and status stored
</verification>

<success_criteria>
- Five atom types defined with Zod discriminated union and inferred TypeScript types
- InboxItem schema allows optional type (pre-classification)
- Dexie database has all tables with correct indexes including *links multi-entry
- Write queue batches writes with 300ms debounce
- Every mutation creates a CRDT-compatible changelog entry
- Four stable sections exist as seed data
- Section items can be created, renamed, archived
- Storage persistence is requested and status is queryable
- Export produces both JSON (via dexie-export-import) and Markdown files
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
