---
phase: 02-compute-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - wasm/core/src/lib.rs
  - wasm/core/Cargo.toml
  - src/types/atoms.ts
  - src/types/messages.ts
  - src/types/config.ts
  - src/worker/worker.ts
  - src/worker/handlers/config.ts
  - src/ui/signals/store.ts
autonomous: true
requirements: [ENTR-01, ENTR-02, ENTR-03, ENTR-06, ENTR-07, ENTR-08, ENTR-10]

must_haves:
  truths:
    - "Rust WASM module computes priority scores for all atoms in a single batch call"
    - "Rust WASM module computes staleness decay with 14-day half-life and onboarding forgiveness"
    - "Rust WASM module computes entropy score from open tasks, stale count, zero-link count, inbox length"
    - "Rust WASM module filters compression prompt candidates (stale + zero-link atoms)"
    - "Worker calls all WASM scoring functions on every STATE_UPDATE and attaches results"
    - "SolidJS store receives and exposes scores, entropyScore, compressionCandidates, and capConfig"
  artifacts:
    - path: "wasm/core/src/lib.rs"
      provides: "compute_scores(), compute_entropy(), filter_compression_candidates() WASM functions"
      contains: "compute_scores"
    - path: "src/types/config.ts"
      provides: "CapConfig, PriorityTier, EnergyLevel, AtomScore, EntropyScore, CompressionCandidate types"
      exports: ["CapConfig", "PriorityTier", "AtomScore", "EntropyScore"]
    - path: "src/worker/handlers/config.ts"
      provides: "getCapConfig and setCapConfig handlers for Dexie config table"
      exports: ["getCapConfig", "setCapConfig"]
    - path: "src/ui/signals/store.ts"
      provides: "Extended BinderState with scores map, entropyScore, compressionCandidates, capConfig, derived cap status signals"
      contains: "capStatus"
  key_links:
    - from: "src/worker/worker.ts"
      to: "wasm/core/src/lib.rs"
      via: "core.compute_scores() call in flushAndSendState"
      pattern: "compute_scores"
    - from: "src/worker/worker.ts"
      to: "src/ui/signals/store.ts"
      via: "STATE_UPDATE postMessage with scores payload"
      pattern: "scores"
    - from: "src/ui/signals/store.ts"
      to: "src/types/config.ts"
      via: "imports AtomScore, EntropyScore, CapConfig types"
      pattern: "AtomScore|EntropyScore|CapConfig"
---

<objective>
Implement the Rust/WASM scoring engine and wire it through the Worker into the SolidJS store. After this plan, every STATE_UPDATE carries computed priority scores, staleness values, entropy health, and compression candidates — but no UI changes yet.

Purpose: This is the data pipeline that gives atoms meaning. All math runs in Rust off the main thread. The store exposes scored data for UI plans to consume.
Output: Extended lib.rs with scoring functions, new config types, worker scoring integration, store with scores/entropy/caps.
</objective>

<execution_context>
@C:/Users/patri/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/patri/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-compute-engine/02-CONTEXT.md
@.planning/phases/02-compute-engine/02-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/01-foundation/01-03-SUMMARY.md

@wasm/core/src/lib.rs
@wasm/core/Cargo.toml
@src/types/atoms.ts
@src/types/messages.ts
@src/worker/worker.ts
@src/ui/signals/store.ts
@src/storage/db.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rust WASM scoring functions + TypeScript types</name>
  <files>
    wasm/core/src/lib.rs
    wasm/core/Cargo.toml
    src/types/config.ts
    src/types/atoms.ts
    src/types/messages.ts
  </files>
  <action>
**Rust (wasm/core/src/lib.rs):** Extend BinderCore with three new public methods. All use serde-wasm-bindgen for type-safe JsValue in/out. NEVER use .unwrap() — always return Result<JsValue, JsValue> with map_err.

1. `compute_scores(&self, atoms_js: JsValue, now_ms: f64) -> Result<JsValue, JsValue>`:
   - Deserialize atoms_js into Vec<AtomInput> via serde_wasm_bindgen::from_value
   - AtomInput struct: id (String), atom_type (String, serde rename "type"), updated_at (f64), created_at (f64), status (String), links (Vec<String>), due_date (Option<f64>), pinned_tier (Option<String>), pinned_staleness (Option<bool>), importance (Option<f64>), energy (Option<String>)
   - For each atom, compute:
     a. Staleness via exponential decay: S(t) = 1 - 2^(-age_ms / effective_half_life). HALF_LIFE = 14 days in ms. If pinned_staleness=true, staleness=0.0. If atom linked to non-stale atoms (staleness < 0.5), multiply half_life by 1.5. If atom created < 30 days ago (ENTR-10 onboarding forgiveness), multiply half_life by 2.0.
     b. Opacity: 1.0 - staleness * 0.4 (range 0.6 to 1.0)
     c. Priority (Tasks and Events ONLY — per CONTEXT.md decision): P = 0.40*deadline_urgency + 0.25*importance + 0.15*recency + 0.15*dependency_urgency + 0.05*energy_boost. If pinned_tier is Some, use fixed score from tier name. deadline_urgency: exponential curve, 1.0 if overdue, 0.0 if >30 days, 1.0 - (days_remaining/30).powf(0.5) otherwise. recency: 1.0 - (age_days/30).min(1.0). dependency_urgency: if any linked atom is a task with high priority score, boost. energy_boost: Quick=0.1, Medium=0.0, Deep=-0.05.
     d. Tier mapping: score >= 0.80 = Critical, >= 0.60 = High, >= 0.40 = Medium, >= 0.20 = Low, else Someday
     e. Energy inference from content heuristic: Quick if content < 50 chars or contains "quick"/"5 min"/"brief"; Deep if content > 200 chars or contains "research"/"write"/"design"/"plan"/"review all"; Medium otherwise. User override (energy field) takes precedence.
   - Return HashMap<String, AtomScore> serialized via serde_wasm_bindgen::to_value
   - AtomScore struct: id, staleness (f64), priority_tier (Option<PriorityTier>), priority_score (f64), energy (EnergyLevel), opacity (f64)
   - PriorityTier enum: Critical, High, Medium, Low, Someday (Serialize/Deserialize)
   - EnergyLevel enum: Quick, Medium, Deep (Serialize/Deserialize)

2. `compute_entropy(&self, atoms_js: JsValue, inbox_count: u32, inbox_cap: u32, task_cap: u32, now_ms: f64) -> Result<JsValue, JsValue>`:
   - Count open tasks (type="task" AND status in ["open","in-progress"]), stale atoms (staleness > 0.7), zero-link atoms (links.len() == 0 AND age > 7 days)
   - Entropy score = 0.35 * (open_tasks/task_cap) + 0.35 * (inbox_count/inbox_cap) + 0.20 * (stale_count/total_atoms) + 0.10 * (zero_link_count/total_atoms)
   - Level: < 0.5 = "green", < 0.75 = "yellow", else "red"
   - Return EntropyScore struct: score (f64), level (String), open_tasks (u32), stale_count (u32), zero_link_count (u32), inbox_count (u32)

3. `filter_compression_candidates(&self, atoms_js: JsValue, now_ms: f64) -> Result<JsValue, JsValue>`:
   - Candidates: atoms with staleness > 0.8 OR (links empty AND created > 14 days ago). Exclude pinned_staleness=true atoms.
   - Return Vec<CompressionCandidate> where CompressionCandidate has: id (String), reason (String like "Stale: 45 days since last edit" or "Orphan: no links to active items"), staleness (f64)

**Cargo.toml:** Verify serde, serde-wasm-bindgen, js-sys, wasm-bindgen are present (they should be from Phase 1). Add serde_json if not already present (needed for serde_json::Value in link deserialization — or use Vec<String> for links).

**TypeScript types (src/types/config.ts — NEW):**
- PriorityTier: "Critical" | "High" | "Medium" | "Low" | "Someday"
- EnergyLevel: "Quick" | "Medium" | "Deep"
- AtomScore: { staleness: number; priorityTier: PriorityTier | null; priorityScore: number; energy: EnergyLevel; opacity: number }
- EntropyScore: { score: number; level: "green" | "yellow" | "red"; openTasks: number; staleCount: number; zeroLinkCount: number; inboxCount: number }
- CompressionCandidate: { id: string; reason: string; staleness: number }
- CapConfig: { inboxCap: number; taskCap: number } with defaults { inboxCap: 20, taskCap: 30 }
- CAP_CONFIG_KEY constant = "cap-config" (for Dexie config table)
- Zod schemas for CapConfig validation (import from 'zod/v4')

**Extend src/types/atoms.ts:** Add optional fields to Atom type: pinned_tier (PriorityTier | null), pinned_staleness (boolean), importance (number | null, 0-1), energy (EnergyLevel | null). Add these to the Zod schema with .optional().

**Extend src/types/messages.ts:** Add new response types: SCORES_UPDATE (not needed if folded into STATE_UPDATE), CAP_EXCEEDED with payload { capType: 'inbox' | 'task'; cap: number }. Add new command: RECOMPUTE_SCORES (no payload, triggers re-score without mutation), UPDATE_CAP_CONFIG with payload CapConfig. Extend STATE_UPDATE response payload to include: scores (Record<string, AtomScore>), entropyScore (EntropyScore), compressionCandidates (CompressionCandidate[]), capConfig (CapConfig).
  </action>
  <verify>
1. Run `pnpm build:wasm` — Rust compiles without errors, WASM binary generated
2. Run `pnpm lint` — zero errors on new TypeScript files
3. Run `pnpm build` — full project builds (TypeScript compiles, Vite bundles)
  </verify>
  <done>
- lib.rs exports compute_scores(), compute_entropy(), filter_compression_candidates() on BinderCore
- All three functions accept JsValue, return Result<JsValue, JsValue>, use serde-wasm-bindgen
- Priority scoring uses the 5-weight formula with tier mapping (Critical/High/Medium/Low/Someday)
- Staleness uses exponential decay with 14-day half-life, link freshness boost, onboarding forgiveness
- TypeScript types (config.ts) match Rust output structs exactly
- Atom schema extended with pinned_tier, pinned_staleness, importance, energy fields
- Message protocol extended with scoring payloads and cap exceeded response
  </done>
</task>

<task type="auto">
  <name>Task 2: Worker scoring integration + store extension + config handler</name>
  <files>
    src/worker/worker.ts
    src/worker/handlers/config.ts
    src/ui/signals/store.ts
  </files>
  <action>
**Worker config handler (src/worker/handlers/config.ts — NEW):**
- getCapConfig(): reads from Dexie config table with key CAP_CONFIG_KEY. If not found, returns default { inboxCap: 20, taskCap: 30 }. Validate with Zod CapConfigSchema on read.
- setCapConfig(config: CapConfig): validates with Zod, enforces guardrails (inbox: min 10, max 30; tasks: min 15, max 50 — per CONTEXT.md), writes to Dexie config table.
- Import db from src/storage/db.ts, use the existing config table pattern (same as classification-log.ts uses).

**Worker integration (src/worker/worker.ts — EXTEND):**
- In flushAndSendState():
  1. After flushing write queue and reading full state (existing code)
  2. Call getCapConfig() to read cap values
  3. Get current time: const now = Date.now()
  4. Call core!.compute_scores(state.atoms, now) — wrap in try/catch, log error if WASM fails, provide empty scores as fallback
  5. Call core!.compute_entropy(state.atoms, state.inboxItems.length, capConfig.inboxCap, capConfig.taskCap, now) — same try/catch pattern
  6. Call core!.filter_compression_candidates(state.atoms, now) — same try/catch pattern
  7. Include scores, entropyScore, compressionCandidates, capConfig in STATE_UPDATE payload
- Add RECOMPUTE_SCORES command handler: calls flushAndSendState() (re-triggers full scoring without mutation)
- Add UPDATE_CAP_CONFIG command handler: calls setCapConfig(), then flushAndSendState()
- Add setInterval(10 * 60 * 1000) in INIT handler to periodically fire RECOMPUTE_SCORES (staleness changes over time even without user interaction)

**Store extension (src/ui/signals/store.ts — EXTEND):**
- Extend BinderState interface with: scores (Record<string, AtomScore>, default {}), entropyScore (EntropyScore | null, default null), compressionCandidates (CompressionCandidate[], default []), capConfig (CapConfig, default { inboxCap: 20, taskCap: 30 }), capExceeded ('inbox' | 'task' | null, default null)
- In STATE_UPDATE handler: reconcile scores, entropyScore, compressionCandidates, capConfig from payload
- Add CAP_EXCEEDED response handler: sets state.capExceeded to payload.capType
- Add derived signals using createMemo:
  - inboxCapStatus(): 'ok' | 'warning' | 'full' — reads state.inboxItems.length and state.capConfig.inboxCap. Full at >= cap, warning at >= 80%, ok otherwise.
  - taskCapStatus(): 'ok' | 'warning' | 'full' — counts atoms where type='task' and status in ['open','in-progress'], compares to state.capConfig.taskCap. Same thresholds.
  - Export both as named exports for StatusBar/CapModal to consume.
- IMPORTANT: Never destructure state — always access state.scores[id], state.entropyScore, etc. through the reactive proxy.
  </action>
  <verify>
1. Run `pnpm build` — full project builds with extended worker and store
2. Run `pnpm lint` — zero errors
3. Run `pnpm dev`, open browser console: verify STATE_UPDATE messages include scores, entropyScore, compressionCandidates, capConfig keys in the payload (inspect with console.log in worker.ts temporarily if needed)
  </verify>
  <done>
- flushAndSendState() calls all three WASM scoring functions and includes results in STATE_UPDATE
- Cap config stored/read from Dexie config table with validation and guardrails
- Store receives and reconciles scores, entropy, candidates, capConfig
- Derived signals inboxCapStatus() and taskCapStatus() compute from store state
- 10-minute periodic re-scoring interval fires in Worker
- CAP_EXCEEDED response handler sets capExceeded flag in store
  </done>
</task>

</tasks>

<verification>
1. `pnpm build:wasm` succeeds — Rust compiles with new scoring functions
2. `pnpm build` succeeds — full project builds
3. `pnpm lint` passes — zero errors
4. In browser dev tools, STATE_UPDATE messages contain scores, entropyScore, compressionCandidates, capConfig
5. Scoring functions return valid data for existing atoms (even with no due dates, the staleness and entropy calculations should produce reasonable defaults)
</verification>

<success_criteria>
- Rust WASM binary includes compute_scores, compute_entropy, filter_compression_candidates
- Worker calls all three on every STATE_UPDATE
- Store exposes scored data via reactive state
- Cap config persisted in Dexie with validation
- Derived cap status signals work correctly
- No WASM panics (all entry points use Result, no .unwrap())
</success_criteria>

<output>
After completion, create `.planning/phases/02-compute-engine/02-01-SUMMARY.md`
</output>
