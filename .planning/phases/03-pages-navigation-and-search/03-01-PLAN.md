---
phase: 03-pages-navigation-and-search
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/storage/db.ts
  - src/storage/migrations/v2.ts
  - src/types/atoms.ts
  - src/types/messages.ts
  - src/worker/handlers/atoms.ts
  - src/worker/worker.ts
  - src/ui/signals/store.ts
  - src/ui/signals/queries.ts
  - src/ui/components/FilterBar.tsx
autonomous: true
requirements:
  - ORG-03
  - ORG-05
  - ORG-06

must_haves:
  truths:
    - "Each default page derives its atom list from state.atoms via createMemo, not from a separate database table"
    - "User can filter any atom list by type, status, date range, section, and priority tier"
    - "User can sort any atom list by date, priority score, last updated, and staleness"
  artifacts:
    - path: "src/storage/migrations/v2.ts"
      provides: "Dexie v2 schema migration adding tags, context, savedFilters table, interactions table"
      contains: "version(2)"
    - path: "src/ui/signals/queries.ts"
      provides: "createMemo query functions for Today, This Week, Active Projects, Waiting, Insights pages plus generic filter/sort chain"
      exports: ["todayAtoms", "thisWeekAtoms", "activeProjectAtoms", "waitingAtoms", "insightAtoms", "filteredAndSortedAtoms"]
      min_lines: 80
    - path: "src/ui/components/FilterBar.tsx"
      provides: "Shared filter/sort controls component with type, status, date range, section, priority tier, and sort options"
      min_lines: 40
    - path: "src/storage/db.ts"
      provides: "Updated Dexie schema with v2 migration, savedFilters table, interactions table"
      contains: "savedFilters"
  key_links:
    - from: "src/ui/signals/queries.ts"
      to: "src/ui/signals/store.ts"
      via: "createMemo reading state.atoms and state.scores"
      pattern: "state\\.atoms\\.filter"
    - from: "src/storage/migrations/v2.ts"
      to: "src/storage/db.ts"
      via: "Dexie version(2) schema definition"
      pattern: "version\\(2\\)"
    - from: "src/ui/components/FilterBar.tsx"
      to: "src/ui/signals/queries.ts"
      via: "filter/sort signals consumed by query memos"
      pattern: "createSignal"
---

<objective>
Schema migration, query engine, and filter/sort infrastructure for Phase 3 pages.

Purpose: Lay the data foundation and reactive query layer that all page views, search, and tag features will consume. Dexie v2 adds tags, context, and new tables. The query engine exposes five page-specific createMemo functions plus a generic filter/sort chain. FilterBar provides the shared UI controls.

Output: Updated Dexie schema (v2), extended atom types with tags/context, reactive query functions for all default pages, reusable FilterBar component.
</objective>

<execution_context>
@C:/Users/patri/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/patri/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-pages-navigation-and-search/03-RESEARCH.md

Key existing files to read:
@src/storage/db.ts (current Dexie v1 schema — extend to v2)
@src/types/atoms.ts (current Zod schemas — add tags, context fields)
@src/types/messages.ts (current Command/Response types — add SEARCH command variant for later use)
@src/ui/signals/store.ts (current state shape — extend with savedFilters, selectedAtomId)
@src/worker/handlers/atoms.ts (current atom handlers — ensure tags/context are preserved on mutations)
@src/worker/worker.ts (worker dispatch — add handler registration for new commands)
@src/types/config.ts (AtomScore, EntropyScore, PriorityTier types used in queries)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dexie v2 schema migration + Zod schema extension + store/worker updates</name>
  <files>
    src/storage/db.ts
    src/storage/migrations/v2.ts
    src/types/atoms.ts
    src/types/messages.ts
    src/worker/handlers/atoms.ts
    src/worker/worker.ts
    src/ui/signals/store.ts
  </files>
  <action>
    **1. Create `src/storage/migrations/v2.ts`:**
    Export an `applyV2Migration(db: BinderDB)` function that:
    - Calls `db.version(2).stores({...})` extending atoms index to include `*tags, context` (multi-entry tags index for efficient tag queries, plain context index for GTD context filtering). Full atoms index string: `'&id, type, status, sectionId, sectionItemId, updated_at, *links, *tags, context'`
    - Adds `savedFilters: '&id, name'` table for saved filter definitions (NAV-07)
    - Adds `interactions: '&id, type, ts'` table for interaction logging (search/filter/click events)
    - Includes `.upgrade()` callback that modifies all existing atoms: `if (!atom.tags) atom.tags = []; if (atom.context === undefined) atom.context = null;`
    - Keep all other existing table definitions unchanged (must re-specify unchanged tables in the same version call)

    **2. Update `src/storage/db.ts`:**
    - Import and call `applyV2Migration` in the BinderDB constructor after the existing `version(1)` block
    - Add table declarations: `savedFilters!: Table<SavedFilter, string>` and `interactions!: Table<InteractionEvent, string>`
    - Define and export `SavedFilter` interface: `{ id: string; name: string; filter: FilterConfig }` where `FilterConfig` is `{ types?: string[]; statuses?: string[]; tags?: string[]; context?: string | null; dateRange?: { from: number; to: number } | null; sectionId?: string | null; priorityTiers?: string[]; sortBy?: 'date' | 'priority' | 'updated' | 'staleness'; sortOrder?: 'asc' | 'desc' }`
    - Define and export `InteractionEvent` interface: `{ id: string; type: 'search' | 'filter' | 'click'; query?: string; atomId?: string; filters?: Record<string, unknown>; ts: number }`

    **3. Update `src/types/atoms.ts`:**
    - Add `tags: z.array(z.string()).default([])` and `context: z.string().nullable().optional()` to the `BaseAtomFields` object (after `energy`)
    - This automatically propagates to all five atom type schemas and the discriminated union since they spread `BaseAtomFields`
    - The `Atom` type will now include `tags: string[]` and `context: string | null | undefined`

    **4. Update `src/types/messages.ts`:**
    - Add `SAVE_FILTER` command: `{ type: 'SAVE_FILTER'; payload: SavedFilter }` (import SavedFilter from db.ts)
    - Add `DELETE_FILTER` command: `{ type: 'DELETE_FILTER'; payload: { id: string } }`
    - Add `LOG_INTERACTION` command: `{ type: 'LOG_INTERACTION'; payload: Omit<InteractionEvent, 'id'> }`
    - Extend STATE_UPDATE response payload to include `savedFilters?: SavedFilter[]`

    **5. Update `src/worker/handlers/atoms.ts`:**
    - Ensure the CREATE_ATOM handler preserves `tags` and `context` fields from the input payload (they should flow through since Zod schema now includes them)
    - Ensure the UPDATE_ATOM handler passes through `tags` and `context` in the `changes` partial

    **6. Update `src/worker/worker.ts`:**
    - Add handler cases for SAVE_FILTER, DELETE_FILTER, LOG_INTERACTION commands
    - SAVE_FILTER: `db.savedFilters.put(payload)` then `flushAndSendState()` with savedFilters
    - DELETE_FILTER: `db.savedFilters.delete(payload.id)` then `flushAndSendState()` with savedFilters
    - LOG_INTERACTION: `db.interactions.add({ ...payload, id: crypto.randomUUID() })`; trim to 1000 entries if count exceeds 1200 (ring buffer with hysteresis to avoid trimming on every write)
    - Include `savedFilters` in the INIT handler's state hydration (read `db.savedFilters.toArray()`)

    **7. Update `src/ui/signals/store.ts`:**
    - Add `savedFilters: SavedFilter[]` to `BinderState` interface (import from db.ts), default `[]`
    - Add `selectedAtomId: string | null` to `BinderState`, default `null`
    - Handle `savedFilters` in STATE_UPDATE and READY response handlers (reconcile)
    - Add `setSelectedAtomId(id: string | null)` setter function export
    - Add derived signal: `selectedAtom = createMemo(() => state.atoms.find(a => a.id === state.selectedAtomId) ?? null)`
  </action>
  <verify>
    Run `npx tsc --noEmit` — no type errors. Verify db.ts compiles with v2 migration. Verify atoms.ts Zod schema includes tags/context. Verify store.ts exports savedFilters and selectedAtomId state.
  </verify>
  <done>
    Dexie v2 migration creates tags/context indexes on atoms, savedFilters table, and interactions table. Atom schema includes tags (string[]) and context (string|null). Store exposes savedFilters, selectedAtomId, and selectedAtom. Worker handles SAVE_FILTER, DELETE_FILTER, and LOG_INTERACTION commands. All types compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Query engine (queries.ts) + FilterBar component</name>
  <files>
    src/ui/signals/queries.ts
    src/ui/components/FilterBar.tsx
  </files>
  <action>
    **1. Create `src/ui/signals/queries.ts`:**

    Import `createMemo` from `solid-js`, `state` from `./store`, types from `../../types/atoms` and `../../types/config`.

    Helper functions (module-level, not exported):
    - `startOfDay()`: returns timestamp for 00:00:00.000 today
    - `endOfDay()`: returns timestamp for 23:59:59.999 today
    - `endOfWeek()`: returns timestamp for end of Sunday (current week)
    - `startOfWeek()`: returns timestamp for 00:00:00 Monday (current week)

    Export five page-specific query memos:

    **`todayAtoms`** — `createMemo(() => Atom[])`:
    - Filter: atoms where status is NOT done/cancelled/archived AND any of:
      - type === 'task' AND dueDate exists AND dueDate <= endOfDay() (due today or overdue)
      - type === 'event' AND eventDate exists AND eventDate >= startOfDay() AND eventDate <= endOfDay()
      - type === 'task' AND state.scores[a.id]?.priorityTier === 'Critical' (top priority)
      - state.scores[a.id]?.staleness > 0.6 (approaching critical staleness)
    - Sort: by priorityScore descending (overdue/critical items bubble up)
    - Limit: no limit (user context: tight daily focus list)

    **`thisWeekAtoms`** — `createMemo(() => Atom[])`:
    - Filter: atoms where status is NOT done/cancelled/archived AND any of:
      - type === 'task' AND dueDate exists AND dueDate <= endOfWeek() AND dueDate >= startOfDay()
      - type === 'event' AND eventDate exists AND eventDate >= startOfDay() AND eventDate <= endOfWeek()
      - type === 'task' AND dueDate exists AND dueDate < startOfDay() (overdue, needs attention)
    - Sort: by dueDate/eventDate ascending (soonest first), then priorityScore desc

    **`activeProjectAtoms`** — `createMemo(() => { sectionItemId: string; sectionItemName: string; atoms: Atom[] }[])`:
    - Group: active tasks by sectionItemId (only atoms in Projects section)
    - For each project group: sort by priorityScore descending — the first atom in each group is the "next action"
    - Only include groups that have at least one atom with status open/in-progress
    - Sort groups by the highest priorityScore in each group (most urgent project first)
    - Use `state.sectionItems` and `state.sections` to resolve project names. Projects section has type 'projects'.

    **`waitingAtoms`** — `createMemo(() => Atom[])`:
    - Filter: atoms where type === 'task' AND status === 'waiting'
    - Sort: by updated_at ascending (longest-waiting first)
    - For each waiting atom, compute staleness alert: `state.scores[a.id]?.staleness > 0.5` means it's been waiting too long

    **`insightAtoms`** — `createMemo(() => Atom[])`:
    - Filter: atoms where type === 'insight' AND status !== 'archived'
    - Sort: by created_at descending (most recent first)

    **Generic filter/sort function** — export `filteredAndSortedAtoms(source: () => Atom[], filters: () => FilterState): () => Atom[]`:
    - This is a higher-order function that creates a createMemo wrapping the source memo with additional filter/sort logic
    - FilterState interface: `{ types: string[]; statuses: string[]; tags: string[]; context: string | null; dateRange: { from: number; to: number } | null; sectionId: string | null; priorityTiers: string[]; sortBy: 'date' | 'priority' | 'updated' | 'staleness'; sortOrder: 'asc' | 'desc' }`
    - Apply filters: if types.length > 0, filter by type; if statuses.length > 0, filter by status; etc.
    - Apply sort: switch on sortBy, apply sortOrder direction
    - Access `state.scores[atom.id]` inside the memo body for priority/staleness sort (SolidJS reactivity tracking)

    **IMPORTANT SolidJS patterns:**
    - Never destructure atoms: use `a.type`, not `const { type } = a`
    - Access `state.scores` inside the memo body (not outside) so SolidJS tracks the dependency
    - Use `createMemo` for all derived data (not plain functions)

    **2. Create `src/ui/components/FilterBar.tsx`:**

    A reusable component that renders filter/sort controls for any page.

    Props interface: `{ filters: FilterState; onFilterChange: (key: keyof FilterState, value: unknown) => void; showTypeFilter?: boolean; showStatusFilter?: boolean; showDateRange?: boolean; showSectionFilter?: boolean; showPriorityFilter?: boolean; showSort?: boolean }`

    Render:
    - A horizontal scrollable bar (class `filter-bar`)
    - **Type filter chips**: Show/Match renders small toggle buttons for each atom type (task, fact, event, decision, insight). Active chips have `filter-chip active` class. Click toggles inclusion in types array.
    - **Status filter chips**: Same pattern for statuses (open, in-progress, waiting, done, cancelled)
    - **Priority tier chips**: Same pattern for tiers (Critical, High, Medium, Low, Someday)
    - **Date range**: Two date inputs (from/to) rendered as small inline inputs, type="date". Convert to timestamps on change.
    - **Section filter**: A `<select>` dropdown with sections from `state.sections`. Value is sectionId or null.
    - **Sort control**: A `<select>` with options: Date, Priority, Last Updated, Staleness. A toggle button for asc/desc.
    - Each filter change calls `props.onFilterChange(key, newValue)`
    - Use `Show when={props.showTypeFilter !== false}` pattern — filters shown by default unless explicitly hidden

    Style notes:
    - Use existing CSS custom properties (`var(--bg-secondary)`, `var(--text-primary)`, etc.)
    - Compact design: filter chips are small pill buttons, 24px height, 8px padding
    - Scrollable horizontally on mobile (overflow-x: auto)
    - Add CSS at the bottom of the file as a `<style>` block or document needed CSS additions for the global stylesheet

    Export `FilterState` type and `createFilterState()` factory function that returns `{ filters: Signal<FilterState>; setFilter: (key, value) => void; resetFilters: () => void }` using `createSignal` — this is the recommended pattern for page components to use.
  </action>
  <verify>
    Run `npx tsc --noEmit` — no type errors. Verify queries.ts exports all five page memos and filteredAndSortedAtoms. Verify FilterBar.tsx renders without errors. Grep for `createMemo` in queries.ts to confirm reactive pattern.
  </verify>
  <done>
    Five page-specific query memos (todayAtoms, thisWeekAtoms, activeProjectAtoms, waitingAtoms, insightAtoms) derive data from state.atoms via createMemo. A generic filteredAndSortedAtoms function wraps any source memo with additional filter/sort logic. FilterBar component provides reusable UI controls for type, status, priority tier, date range, section, and sort. All filters are reactive via SolidJS signals.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. Dexie v2 migration can be verified by inspecting IndexedDB schema in browser DevTools after app load
3. `todayAtoms`, `waitingAtoms`, etc. return correct subsets when atoms with appropriate statuses/dates exist
4. FilterBar renders filter chips and sort controls; toggling a chip updates the filter state signal
5. No SolidJS reactivity violations (no destructured state/atoms in memos)
</verification>

<success_criteria>
- Dexie database opens at version 2 with tags, context, savedFilters, interactions tables
- Atom Zod schema validates tags (string[]) and context (string|null) fields
- Five createMemo query functions return correct atom subsets based on type, status, dates, and scores
- FilterBar component renders and is interactive (chip toggles update filter signals)
- Store includes savedFilters array and selectedAtomId with setter
- Worker handles SAVE_FILTER, DELETE_FILTER, LOG_INTERACTION commands
- All TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/03-pages-navigation-and-search/03-01-SUMMARY.md`
</output>
