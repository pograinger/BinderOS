---
phase: 03-pages-navigation-and-search
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/search/search-index.ts
  - src/search/ranking.ts
  - src/search/embedding-worker.ts
  - src/ui/views/SearchOverlay.tsx
  - src/ui/components/CommandPalette.tsx
  - src/ui/components/ShortcutReference.tsx
  - src/app.tsx
  - package.json
autonomous: true
requirements:
  - NAV-01
  - NAV-02
  - NAV-03
  - NAV-04

must_haves:
  truths:
    - "User can full-text search across all atom types with results ranked by relevance"
    - "Search supports filtering by type, status, and date range inline"
    - "User can navigate the entire system via keyboard — arrow keys in lists, hotkeys for actions"
    - "Command palette is accessible via Cmd/Ctrl+P and lists available actions"
    - "Search is accessible via Cmd/Ctrl+K as a Spotlight-style overlay"
    - "Shortcut reference is accessible via ? key"
  artifacts:
    - path: "src/search/search-index.ts"
      provides: "MiniSearch full-text index with rebuild-on-change, search, and auto-suggest"
      exports: ["rebuildIndex", "searchAtoms", "autoSuggest"]
      min_lines: 30
    - path: "src/search/ranking.ts"
      provides: "Blended relevance score combining text match, semantic similarity, graph proximity, and priority"
      exports: ["blendedScore"]
    - path: "src/search/embedding-worker.ts"
      provides: "Web Worker for ONNX model inference via Transformers.js (lazy-loaded)"
      min_lines: 30
    - path: "src/ui/views/SearchOverlay.tsx"
      provides: "Spotlight-style search overlay with type-ahead results, filter chips, and keyboard navigation"
      min_lines: 60
    - path: "src/ui/components/CommandPalette.tsx"
      provides: "Command palette listing all available actions with fuzzy search"
      min_lines: 40
    - path: "src/ui/components/ShortcutReference.tsx"
      provides: "Keyboard shortcut reference sheet"
      min_lines: 20
  key_links:
    - from: "src/ui/views/SearchOverlay.tsx"
      to: "src/search/search-index.ts"
      via: "calls searchAtoms() on debounced input"
      pattern: "searchAtoms"
    - from: "src/ui/views/SearchOverlay.tsx"
      to: "src/search/embedding-worker.ts"
      via: "postMessage for semantic re-ranking of top results"
      pattern: "postMessage.*EMBED"
    - from: "src/search/ranking.ts"
      to: "src/ui/signals/store.ts"
      via: "reads state.scores for priority score and graph proximity"
      pattern: "state\\.scores"
    - from: "src/app.tsx"
      to: "src/ui/views/SearchOverlay.tsx"
      via: "Ctrl+K shortcut opens overlay; overlay state signal controls visibility"
      pattern: "Ctrl.*[kK]"
---

<objective>
Full-text search, semantic search, keyboard navigation, and command palette.

Purpose: Users can find any atom instantly via Cmd/Ctrl+K search (text + semantic), navigate the system entirely by keyboard, and access all actions via Cmd/Ctrl+P command palette. Search results are ranked by blended relevance (text match, semantic similarity, graph proximity, priority score). Vector embeddings run in a dedicated worker with graceful degradation.

Output: MiniSearch integration, Transformers.js embedding worker, Spotlight-style search overlay, command palette, keyboard navigation system, shortcut reference sheet.
</objective>

<execution_context>
@C:/Users/patri/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/patri/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-pages-navigation-and-search/03-RESEARCH.md
@.planning/phases/03-pages-navigation-and-search/03-01-SUMMARY.md

Key existing files to read:
@src/app.tsx (current keyboard shortcuts — extend with Ctrl+K, Ctrl+P, ?, overlay state)
@src/ui/signals/store.ts (state.atoms for search index, state.scores for ranking)
@src/ui/components/AtomCard.tsx (reference for result item rendering)
@src/types/atoms.ts (Atom type shape for search indexing)
@src/types/config.ts (AtomScore for priority/staleness in ranking)
@package.json (verify minisearch installed; add @huggingface/transformers)
</context>

<tasks>

<task type="auto">
  <name>Task 1: MiniSearch index + search overlay + vector embeddings + ranking</name>
  <files>
    src/search/search-index.ts
    src/search/ranking.ts
    src/search/embedding-worker.ts
    src/ui/views/SearchOverlay.tsx
    package.json
  </files>
  <action>
    **0. Install dependencies:**
    ```bash
    pnpm add minisearch @huggingface/transformers
    ```
    Note: `@types/minisearch` is not needed — MiniSearch ships its own TypeScript types.

    **1. Create `src/search/search-index.ts`:**

    MiniSearch singleton that indexes all atoms.

    ```typescript
    import MiniSearch from 'minisearch';
    import type { Atom } from '../types/atoms';

    export interface SearchResult {
      id: string;
      score: number;
      match: Record<string, string[]>;
      terms: string[];
      // Stored fields for display without re-lookup
      type: string;
      status: string;
      title: string;
      updated_at: number;
    }
    ```

    Create MiniSearch instance with:
    - `fields: ['title', 'content']` — fields to index for full-text search
    - `storeFields: ['id', 'type', 'status', 'title', 'updated_at', 'sectionId']` — fields returned in results
    - `searchOptions: { boost: { title: 2 }, fuzzy: 0.2, prefix: true }` — title matches weighted 2x, typo tolerance, prefix matching for type-ahead

    Export functions:
    - `rebuildIndex(atoms: Atom[]): void` — `miniSearch.removeAll(); miniSearch.addAll(atoms)` — called when state.atoms changes
    - `searchAtoms(query: string, filter?: { types?: string[]; statuses?: string[]; dateRange?: { from: number; to: number } }): SearchResult[]` — calls `miniSearch.search(query, { filter: (result) => { ... } })`. Apply type/status/date filters using MiniSearch's `filter` option. Return typed results.
    - `autoSuggest(query: string): string[]` — calls `miniSearch.autoSuggest(query, { fuzzy: 0.2 })` and returns suggestion strings

    **2. Create `src/search/ranking.ts`:**

    Blended relevance score function.

    ```typescript
    interface RankingInput {
      textScore: number;         // MiniSearch score, normalized 0-1
      semanticScore: number;     // cosine similarity 0-1 (0 if embeddings not ready)
      graphProximity: number;    // 0 or 1: 1 if linked to any recently-updated atom
      priorityScore: number;     // from state.scores[id].priorityScore (0-1)
    }
    ```

    Export `blendedScore(input: RankingInput): number`:
    - When semanticScore > 0: `0.40 * textScore + 0.25 * semanticScore + 0.20 * graphProximity + 0.15 * priorityScore`
    - When semanticScore === 0 (embeddings not yet loaded): `0.55 * textScore + 0.25 * graphProximity + 0.20 * priorityScore`
    - This avoids penalizing results before embeddings are ready

    Export `normalizeTextScore(scores: SearchResult[]): SearchResult[]`:
    - Normalize MiniSearch scores to 0-1 range by dividing by max score in result set

    Export `computeGraphProximity(atomId: string, atoms: Atom[], recentThresholdMs: number): number`:
    - Check if atom has links to any atom updated within `recentThresholdMs` (default 7 days)
    - Return 1.0 if linked to recent atoms, 0.0 otherwise

    **3. Create `src/search/embedding-worker.ts`:**

    A dedicated Web Worker for ONNX model inference.

    Worker message protocol:
    - Incoming: `{ type: 'EMBED'; id: string; texts: string[] }` — embed the given texts
    - Incoming: `{ type: 'EMBED_ATOMS'; atoms: { id: string; text: string }[] }` — embed all atoms (batch)
    - Outgoing: `{ type: 'EMBED_RESULT'; id: string; vectors: number[][] }` — embedding results
    - Outgoing: `{ type: 'EMBED_ERROR'; id: string; error: string }` — error fallback
    - Outgoing: `{ type: 'MODEL_READY' }` — model loaded, ready for queries
    - Outgoing: `{ type: 'MODEL_LOADING' }` — model is downloading/loading

    Implementation:
    - `import { pipeline, env } from '@huggingface/transformers';`
    - Set `env.allowRemoteModels = true` (first load fetches from HuggingFace CDN)
    - Lazy-load the pipeline on first EMBED message (not on worker creation)
    - Use model `'Xenova/all-MiniLM-L6-v2'` with `{ quantized: true }` (int8, ~22MB)
    - Send `MODEL_LOADING` before loading, `MODEL_READY` after
    - On EMBED: get pipeline, run inference with `{ pooling: 'mean', normalize: true }`, return vectors
    - On EMBED_ATOMS: batch embed all atom texts, return { id, vector } pairs
    - All errors caught and returned as EMBED_ERROR (graceful degradation)

    Also export a `cosineSimilarity(a: Float32Array | number[], b: Float32Array | number[]): number` function in a separate file or at the top of ranking.ts for use by the search overlay.

    **4. Create `src/ui/views/SearchOverlay.tsx`:**

    Spotlight-style search overlay (per CONTEXT.md).

    Props: `{ onClose: () => void }`

    Structure:
    - **Backdrop**: semi-transparent overlay (click to close)
    - **Search container**: Centered, 600px wide, max-height 70vh
    - **Search input**: Auto-focused text input, placeholder "Search atoms..."
    - **Filter chips row**: Below input. Small toggle chips for type (task, fact, event, decision, insight), status (open, in-progress, waiting, done), and date range (today, this week, this month, custom). Active chips filter results.
    - **Results list**: Scrollable list of search results with roving tabindex keyboard navigation
    - **Loading indicator**: "Enhancing with semantic search..." shown when embedding worker is loading
    - **Empty state**: "No results found" or type-ahead suggestions from autoSuggest()

    Search flow:
    1. User types in input (debounced 150ms via setTimeout/clearTimeout)
    2. Call `searchAtoms(query, { types, statuses, dateRange })` from search-index.ts
    3. Normalize text scores via `normalizeTextScore()`
    4. For each result, compute `computeGraphProximity()` and read `state.scores[id].priorityScore`
    5. Compute `blendedScore()` for each result
    6. Sort by blended score descending
    7. Display results
    8. In parallel: send query to embedding worker for semantic re-ranking
    9. When EMBED_RESULT arrives, compute cosine similarity between query vector and pre-computed atom vectors
    10. Recompute blended scores with semantic component and re-sort (smooth transition, don't flash)

    Keyboard navigation in results:
    - ArrowDown/ArrowUp: move focus through results (roving tabindex pattern from RESEARCH.md Pattern 5)
    - Enter: open selected atom (call `setSelectedAtomId(result.id)` and close overlay)
    - Escape: close overlay
    - Tab: move from input to filter chips to results

    Interaction logging (data foundation per CONTEXT.md):
    - On search execution: `sendCommand({ type: 'LOG_INTERACTION', payload: { type: 'search', query, ts: Date.now() } })`
    - On result click: `sendCommand({ type: 'LOG_INTERACTION', payload: { type: 'click', atomId, query, ts: Date.now() } })`
    - On filter change: `sendCommand({ type: 'LOG_INTERACTION', payload: { type: 'filter', filters: activeFilters, ts: Date.now() } })`

    MiniSearch index management:
    - Use `createEffect` in the search overlay (or at app level) that watches `state.atoms.length` and calls `rebuildIndex(state.atoms)` when it changes
    - Alternatively, rebuild index once on overlay open and keep it in sync. Prefer the createEffect approach at app level (inside SearchOverlay or a dedicated signal file) so the index is always ready.

    Embedding worker lifecycle:
    - Create worker instance lazily on first search overlay open: `new Worker(new URL('../search/embedding-worker.ts', import.meta.url), { type: 'module' })`
    - Send EMBED_ATOMS on first open to pre-compute atom embeddings (cached in memory)
    - Store atom vectors in a Map<string, number[]> on the main thread (sent back from worker)
    - On query, embed the query text and compute cosine similarity against stored vectors
    - If worker not ready, show text-only results (graceful degradation — never block search)

    **CSS:**
    - `.search-overlay-backdrop`: fixed full-screen, z-index high (above detail panel)
    - `.search-overlay-container`: centered, 600px wide, rounded corners, dark bg
    - `.search-input`: full width, large font, no border, focus ring
    - `.search-filter-chips`: horizontal row, small toggleable chips
    - `.search-result-item`: compact row with type icon, title, score indicator
    - `.search-result-item.focused`: highlighted background
    - Follow existing dark theme
  </action>
  <verify>
    Run `npx tsc --noEmit`. Start dev server, press Ctrl+K — verify search overlay opens. Type a query — verify results appear with type-ahead. Click a result — verify atom detail opens. Toggle filter chips — verify results update. Press Escape — verify overlay closes. Check console for embedding worker messages (MODEL_LOADING, MODEL_READY). Verify search still works if embedding worker fails to load (graceful degradation).
  </verify>
  <done>
    MiniSearch indexes all atoms on state change. Search overlay opens via Ctrl+K with instant type-ahead results. Results are ranked by blended score (text + semantic + graph + priority). Filter chips narrow results by type, status, date range. Embedding worker lazy-loads ONNX model for semantic search with graceful fallback. Interaction events logged for future learning. Keyboard navigation (arrow keys) works in result list.
  </done>
</task>

<task type="auto">
  <name>Task 2: Command palette + keyboard navigation + shortcut reference + overlay management</name>
  <files>
    src/ui/components/CommandPalette.tsx
    src/ui/components/ShortcutReference.tsx
    src/app.tsx
  </files>
  <action>
    **1. Create `src/ui/components/CommandPalette.tsx`:**

    A command palette (separate from search per CONTEXT.md) listing all available actions.

    Props: `{ onClose: () => void }`

    Structure:
    - **Backdrop**: semi-transparent overlay
    - **Palette container**: Centered, 500px wide, max-height 60vh
    - **Input**: Auto-focused, placeholder "Type a command..."
    - **Command list**: Filterable list of commands with fuzzy matching

    Command definitions (static array):
    ```typescript
    interface PaletteCommand {
      id: string;
      label: string;
      shortcut?: string;
      category: 'navigation' | 'action' | 'recent';
      action: () => void;
    }
    ```

    Commands to include:
    - **Navigation**: Go to Today (set activePage to 'today'), Go to This Week, Go to Active Projects, Go to Waiting, Go to Insights, Go to Inbox, Go to All Items, Go to Review
    - **Actions**: New Capture (open capture overlay), Undo (send UNDO command), Export Data (send EXPORT_DATA), Request Persistence, Search (open search overlay)
    - **Recent atoms**: Last 5 atoms from `state.atoms` sorted by updated_at desc — clicking navigates to atom detail

    Fuzzy filtering:
    - Filter commands by fuzzy matching on label: split query into words, check if each word appears as a substring in the label (case-insensitive). Simple approach, not MiniSearch (overkill for ~20 commands).

    Keyboard navigation:
    - ArrowDown/ArrowUp: roving tabindex through filtered results
    - Enter: execute selected command and close palette
    - Escape: close palette

    **2. Create `src/ui/components/ShortcutReference.tsx`:**

    A reference sheet showing all keyboard shortcuts.

    Props: `{ onClose: () => void }`

    Structure:
    - Modal/overlay with backdrop
    - Title: "Keyboard Shortcuts"
    - Grid layout of shortcut categories:

    | Category | Shortcut | Action |
    |----------|----------|--------|
    | Global | Ctrl/Cmd + N | Quick capture |
    | Global | Ctrl/Cmd + K | Search |
    | Global | Ctrl/Cmd + P | Command palette |
    | Global | Ctrl/Cmd + Z | Undo |
    | Global | ? | Shortcut reference |
    | Global | Escape | Close overlay/panel |
    | Navigation | 1-5 | Switch to page 1-5 |
    | Lists | Arrow Up/Down | Navigate items |
    | Lists | Enter | Open selected item |
    | Search | Arrow Up/Down | Navigate results |
    | Search | Enter | Open selected result |
    | Detail | Escape | Close detail panel |

    Render each shortcut as: `<kbd>` tag for the key combo + description text.

    **3. Update `src/app.tsx`:**

    Replace the current `showCapture` signal with a unified overlay state:

    ```typescript
    type OverlayState = 'none' | 'capture' | 'search' | 'command-palette' | 'shortcuts';
    const [overlay, setOverlay] = createSignal<OverlayState>('none');
    ```

    Update the handleKeyDown function:

    - `Ctrl+N / Cmd+N`: `setOverlay(overlay() === 'capture' ? 'none' : 'capture')` (toggle)
    - `Ctrl+K / Cmd+K`: `setOverlay('search')` — always opens search (CONTEXT.md: separate from command palette)
    - `Ctrl+P / Cmd+P`: `setOverlay('command-palette')`
    - `?` key (when not in an input field): `setOverlay('shortcuts')` — check `document.activeElement?.tagName` is not INPUT/TEXTAREA/SELECT before triggering
    - `Escape`: `setOverlay('none')` (close whatever is open). Also close atom detail panel if no overlay is open: `if (overlay() === 'none') setSelectedAtomId(null)`
    - Number keys 1-5 (when not in input): Switch pages — 1=today, 2=this-week, 3=active-projects, 4=waiting, 5=insights. Call `setActivePage(pageId)`.

    Helper function `isInputFocused()`:
    ```typescript
    function isInputFocused(): boolean {
      const tag = document.activeElement?.tagName;
      return tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT';
    }
    ```

    Update the JSX:
    - Replace `<Show when={showCapture()}>` with `<Show when={overlay() === 'capture'}>`
    - Add `<Show when={overlay() === 'search'}><SearchOverlay onClose={() => setOverlay('none')} /></Show>`
    - Add `<Show when={overlay() === 'command-palette'}><CommandPalette onClose={() => setOverlay('none')} /></Show>`
    - Add `<Show when={overlay() === 'shortcuts'}><ShortcutReference onClose={() => setOverlay('none')} /></Show>`
    - Update FAB button to use `setOverlay('capture')`
    - Keep CapEnforcementModal and StorageWarning as-is (they're not part of the overlay system)

    **Keyboard navigation for atom lists (NAV-03):**
    The roving tabindex pattern is built into SearchOverlay and CommandPalette (Task 1 and above). For page atom lists, add to app.tsx handleKeyDown:
    - When no overlay is open and no input focused: ArrowDown/ArrowUp should dispatch a custom event or update a `focusedCardIndex` signal that AtomCard lists can consume
    - Simpler approach: each page component manages its own keyboard navigation using its own `keydown` handler on the list container (not in app.tsx). The app.tsx global handler only manages overlays and shortcuts. Page-level keyboard nav is handled within page components via the roving tabindex pattern already specified in SearchOverlay.

    **IMPORTANT per CONTEXT.md:**
    - Command palette is SEPARATE from search (different overlay, different shortcut)
    - Search is Spotlight-style (Ctrl+K)
    - Command palette lists actions + recent atoms (Ctrl+P)
    - Mobile: FAB button in bottom-right already exists for capture. Command palette mobile access via the same FAB long-press or a menu item (defer complex mobile FAB to v2; for now, command palette is keyboard-only)

    **Discoverability (CONTEXT.md):**
    - Tooltips on interactive elements should include shortcut hints (e.g., capture button title includes "(Ctrl+N)")
    - This is already partially done. Ensure new buttons/tabs include shortcut hints in `title` attributes.

    Pass `setOverlay` to CommandPalette so it can trigger the search overlay as a command action.

    **CSS:**
    - `.command-palette-backdrop`, `.command-palette-container`: similar to search overlay
    - `.command-palette-input`: full width, medium font
    - `.command-item`: row with label, shortcut badge, hover highlight
    - `.shortcut-reference-overlay`: modal with grid layout
    - `kbd`: styled key indicator (border, rounded, small padding, mono font)
  </action>
  <verify>
    Run `npx tsc --noEmit`. Start dev server. Press Ctrl+K — search opens. Press Escape, then Ctrl+P — command palette opens. Type "today" — verify "Go to Today" command appears. Press Enter — verify page switches to Today. Press ? — verify shortcut reference opens. Press 1-5 — verify page switching. Verify only one overlay can be open at a time (Ctrl+K while palette is open should switch to search).
  </verify>
  <done>
    Command palette opens via Ctrl+P with fuzzy-filterable actions (navigation, captures, recent atoms). Search overlay opens via Ctrl+K (separate from palette). Shortcut reference opens via ? key. Unified overlay state prevents stacking. Number keys 1-5 switch pages. Escape closes overlays. Arrow keys navigate within overlays. All shortcuts have tooltip hints for discoverability.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `pnpm add minisearch @huggingface/transformers` installs without errors
3. Ctrl+K opens search, type-ahead returns relevant results
4. Ctrl+P opens command palette, commands are filterable and executable
5. ? opens shortcut reference sheet
6. Escape closes any open overlay; only one overlay open at a time
7. Number keys 1-5 switch between default pages
8. Arrow keys navigate search results and command palette items
9. Search filter chips narrow results by type/status/date
10. Embedding worker loads gracefully; search works without embeddings (fallback to text-only)
</verification>

<success_criteria>
- Full-text search returns ranked results across all atom types (NAV-01)
- Search supports inline filtering by type, status, date range (NAV-02)
- Keyboard navigation works throughout: overlays, lists, page switching (NAV-03)
- Command palette lists all actions and is accessible via Ctrl+P (NAV-04)
- Vector embeddings enhance ranking when available, degrade gracefully when not
- Only one overlay open at a time; Escape always closes current overlay
- Interaction events are logged for future learning
</success_criteria>

<output>
After completion, create `.planning/phases/03-pages-navigation-and-search/03-03-SUMMARY.md`
</output>
