---
phase: 03-pages-navigation-and-search
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/search/search-index.ts
  - src/search/ranking.ts
  - src/search/embedding-worker.ts
  - src/ui/views/SearchOverlay.tsx
  - src/ui/components/CommandPalette.tsx
  - src/ui/components/ShortcutReference.tsx
  - src/ui/hooks/useRovingTabindex.ts
  - src/app.tsx
  - package.json
  - scripts/download-model.cjs
  - .gitignore
autonomous: true
requirements:
  - NAV-01
  - NAV-02
  - NAV-03
  - NAV-04

must_haves:
  truths:
    - "User can full-text search across all atom types with results ranked by relevance"
    - "Search supports filtering by type, status, and date range inline"
    - "User can navigate the entire system via keyboard — arrow keys in lists, hotkeys for actions"
    - "Command palette is accessible via Cmd/Ctrl+P and lists available actions"
    - "Search is accessible via Cmd/Ctrl+K as a Spotlight-style overlay"
    - "Shortcut reference is accessible via ? key"
  artifacts:
    - path: "src/search/search-index.ts"
      provides: "MiniSearch full-text index with rebuild-on-change, search, and auto-suggest"
      exports: ["rebuildIndex", "searchAtoms", "autoSuggest"]
      min_lines: 30
    - path: "src/search/ranking.ts"
      provides: "Blended relevance score combining text match, semantic similarity, graph proximity, and priority"
      exports: ["blendedScore"]
    - path: "src/search/embedding-worker.ts"
      provides: "Web Worker for ONNX model inference via Transformers.js (lazy-loaded, local model only — zero network calls)"
      min_lines: 30
    - path: "src/ui/views/SearchOverlay.tsx"
      provides: "Spotlight-style search overlay with type-ahead results, filter chips, and keyboard navigation"
      min_lines: 60
    - path: "src/ui/components/CommandPalette.tsx"
      provides: "Command palette listing all available actions with fuzzy search"
      min_lines: 40
    - path: "src/ui/components/ShortcutReference.tsx"
      provides: "Keyboard shortcut reference sheet"
      min_lines: 20
    - path: "src/ui/hooks/useRovingTabindex.ts"
      provides: "Shared roving tabindex hook for arrow key navigation in lists (search results, command palette, page atom lists)"
      exports: ["useRovingTabindex"]
      min_lines: 30
  key_links:
    - from: "src/ui/views/SearchOverlay.tsx"
      to: "src/search/search-index.ts"
      via: "calls searchAtoms() on debounced input"
      pattern: "searchAtoms"
    - from: "src/ui/views/SearchOverlay.tsx"
      to: "src/search/embedding-worker.ts"
      via: "postMessage for semantic re-ranking of top results"
      pattern: "postMessage.*EMBED"
    - from: "src/search/ranking.ts"
      to: "src/ui/signals/store.ts"
      via: "reads state.scores for priority score and graph proximity"
      pattern: "state\\.scores"
    - from: "src/app.tsx"
      to: "src/ui/views/SearchOverlay.tsx"
      via: "Ctrl+K shortcut opens overlay; overlay state signal controls visibility"
      pattern: "Ctrl.*[kK]"
---

<objective>
Full-text search, semantic search, keyboard navigation, and command palette.

Purpose: Users can find any atom instantly via Cmd/Ctrl+K search (text + semantic), navigate the system entirely by keyboard, and access all actions via Cmd/Ctrl+P command palette. Search results are ranked by blended relevance (text match, semantic similarity, graph proximity, priority score). Vector embeddings run in a dedicated worker with graceful degradation.

Output: MiniSearch integration, Transformers.js embedding worker, Spotlight-style search overlay, command palette, keyboard navigation system, shortcut reference sheet.
</objective>

<execution_context>
@C:/Users/patri/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/patri/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-pages-navigation-and-search/03-RESEARCH.md
@.planning/phases/03-pages-navigation-and-search/03-01-SUMMARY.md

Key existing files to read:
@src/app.tsx (current keyboard shortcuts — extend with Ctrl+K, Ctrl+P, ?, overlay state)
@src/ui/signals/store.ts (state.atoms for search index, state.scores for ranking)
@src/ui/components/AtomCard.tsx (reference for result item rendering)
@src/types/atoms.ts (Atom type shape for search indexing)
@src/types/config.ts (AtomScore for priority/staleness in ranking)
@package.json (verify minisearch installed; add @huggingface/transformers)
</context>

<tasks>

<task type="auto">
  <name>Task 1: MiniSearch index + search overlay + vector embeddings + ranking</name>
  <files>
    src/search/search-index.ts
    src/search/ranking.ts
    src/search/embedding-worker.ts
    src/ui/views/SearchOverlay.tsx
    package.json
    scripts/download-model.cjs
    .gitignore
  </files>
  <action>
    **0. Install dependencies + bundle ONNX model locally:**
    ```bash
    pnpm add minisearch @huggingface/transformers
    ```
    Note: `@types/minisearch` is not needed — MiniSearch ships its own TypeScript types.

    **CRITICAL — Local-first model bundling (per locked user decision: zero network calls):**
    The quantized ONNX model files for `Xenova/all-MiniLM-L6-v2` must be shipped with the app, not fetched from HuggingFace CDN at runtime.

    Steps to bundle the model:
    1. Add a `postinstall` script to `package.json`:
       ```json
       "scripts": {
         "postinstall:models": "node scripts/download-model.cjs"
       }
       ```
    2. Create `scripts/download-model.cjs` — a Node.js script that:
       - Checks if `public/models/Xenova/all-MiniLM-L6-v2/` already exists (skip if so)
       - Downloads the quantized ONNX model files from HuggingFace Hub into `public/models/Xenova/all-MiniLM-L6-v2/`
       - Required files: `onnx/model_quantized.onnx`, `tokenizer.json`, `tokenizer_config.json`, `config.json`
       - This runs ONCE at install time on the developer machine, not at runtime in the browser
       - Log progress: "Downloading ONNX model for local semantic search..."
    3. Add `public/models/` to `.gitignore` (binary files, downloaded at install time)
    4. Vite automatically serves files from `public/` at the root path, so the model will be available at `/models/Xenova/all-MiniLM-L6-v2/` at runtime

    This ensures ZERO network calls from the browser. The model is bundled into the app's static assets.

    **1. Create `src/search/search-index.ts`:**

    MiniSearch singleton that indexes all atoms.

    ```typescript
    import MiniSearch from 'minisearch';
    import type { Atom } from '../types/atoms';

    export interface SearchResult {
      id: string;
      score: number;
      match: Record<string, string[]>;
      terms: string[];
      // Stored fields for display without re-lookup
      type: string;
      status: string;
      title: string;
      updated_at: number;
    }
    ```

    Create MiniSearch instance with:
    - `fields: ['title', 'content']` — fields to index for full-text search
    - `storeFields: ['id', 'type', 'status', 'title', 'updated_at', 'sectionId']` — fields returned in results
    - `searchOptions: { boost: { title: 2 }, fuzzy: 0.2, prefix: true }` — title matches weighted 2x, typo tolerance, prefix matching for type-ahead

    Export functions:
    - `rebuildIndex(atoms: Atom[]): void` — `miniSearch.removeAll(); miniSearch.addAll(atoms)` — called when state.atoms changes
    - `searchAtoms(query: string, filter?: { types?: string[]; statuses?: string[]; dateRange?: { from: number; to: number } }): SearchResult[]` — calls `miniSearch.search(query, { filter: (result) => { ... } })`. Apply type/status/date filters using MiniSearch's `filter` option. Return typed results.
    - `autoSuggest(query: string): string[]` — calls `miniSearch.autoSuggest(query, { fuzzy: 0.2 })` and returns suggestion strings

    **2. Create `src/search/ranking.ts`:**

    Blended relevance score function.

    ```typescript
    interface RankingInput {
      textScore: number;         // MiniSearch score, normalized 0-1
      semanticScore: number;     // cosine similarity 0-1 (0 if embeddings not ready)
      graphProximity: number;    // 0 or 1: 1 if linked to any recently-updated atom
      priorityScore: number;     // from state.scores[id].priorityScore (0-1)
    }
    ```

    Export `blendedScore(input: RankingInput): number`:
    - When semanticScore > 0: `0.40 * textScore + 0.25 * semanticScore + 0.20 * graphProximity + 0.15 * priorityScore`
    - When semanticScore === 0 (embeddings not yet loaded): `0.55 * textScore + 0.25 * graphProximity + 0.20 * priorityScore`
    - This avoids penalizing results before embeddings are ready

    Export `normalizeTextScore(scores: SearchResult[]): SearchResult[]`:
    - Normalize MiniSearch scores to 0-1 range by dividing by max score in result set

    Export `computeGraphProximity(atomId: string, atoms: Atom[], recentThresholdMs: number): number`:
    - Check if atom has links to any atom updated within `recentThresholdMs` (default 7 days)
    - Return 1.0 if linked to recent atoms, 0.0 otherwise

    **3. Create `src/search/embedding-worker.ts`:**

    A dedicated Web Worker for ONNX model inference.

    Worker message protocol:
    - Incoming: `{ type: 'EMBED'; id: string; texts: string[] }` — embed the given texts
    - Incoming: `{ type: 'EMBED_ATOMS'; atoms: { id: string; text: string }[] }` — embed all atoms (batch)
    - Outgoing: `{ type: 'EMBED_RESULT'; id: string; vectors: number[][] }` — embedding results
    - Outgoing: `{ type: 'EMBED_ERROR'; id: string; error: string }` — error fallback
    - Outgoing: `{ type: 'MODEL_READY' }` — model loaded, ready for queries
    - Outgoing: `{ type: 'MODEL_LOADING' }` — model is downloading/loading

    Implementation:
    - `import { pipeline, env } from '@huggingface/transformers';`
    - **CRITICAL (locked decision — zero network calls):** Configure for local-only model loading:
      ```typescript
      env.allowRemoteModels = false;  // NEVER fetch from HuggingFace CDN at runtime
      env.allowLocalModels = true;    // Load from bundled local files only
      env.localModelPath = '/models/'; // Served by Vite from public/models/
      ```
    - Lazy-load the pipeline on first EMBED message (not on worker creation)
    - Use model `'Xenova/all-MiniLM-L6-v2'` with `{ quantized: true }` (int8, ~22MB, pre-bundled in public/models/)
    - Send `MODEL_LOADING` before loading, `MODEL_READY` after
    - If model files are missing (e.g., postinstall didn't run), catch the error and send `EMBED_ERROR` with a helpful message: "ONNX model not found. Run pnpm postinstall:models to download."
    - On EMBED: get pipeline, run inference with `{ pooling: 'mean', normalize: true }`, return vectors
    - On EMBED_ATOMS: batch embed all atom texts, return { id, vector } pairs
    - All errors caught and returned as EMBED_ERROR (graceful degradation)

    Also export a `cosineSimilarity(a: Float32Array | number[], b: Float32Array | number[]): number` function in a separate file or at the top of ranking.ts for use by the search overlay.

    **4. Create `src/ui/views/SearchOverlay.tsx`:**

    Spotlight-style search overlay (per CONTEXT.md).

    Props: `{ onClose: () => void }`

    Structure:
    - **Backdrop**: semi-transparent overlay (click to close)
    - **Search container**: Centered, 600px wide, max-height 70vh
    - **Search input**: Auto-focused text input, placeholder "Search atoms..."
    - **Filter chips row**: Below input. Small toggle chips for type (task, fact, event, decision, insight), status (open, in-progress, waiting, done), and date range (today, this week, this month, custom). Active chips filter results.
    - **Results list**: Scrollable list of search results with roving tabindex keyboard navigation
    - **Loading indicator**: "Enhancing with semantic search..." shown when embedding worker is loading
    - **Empty state**: "No results found" or type-ahead suggestions from autoSuggest()

    Search flow:
    1. User types in input (debounced 150ms via setTimeout/clearTimeout)
    2. Call `searchAtoms(query, { types, statuses, dateRange })` from search-index.ts
    3. Normalize text scores via `normalizeTextScore()`
    4. For each result, compute `computeGraphProximity()` and read `state.scores[id].priorityScore`
    5. Compute `blendedScore()` for each result
    6. Sort by blended score descending
    7. Display results
    8. In parallel: send query to embedding worker for semantic re-ranking
    9. When EMBED_RESULT arrives, compute cosine similarity between query vector and pre-computed atom vectors
    10. Recompute blended scores with semantic component and re-sort (smooth transition, don't flash)

    Keyboard navigation in results:
    - ArrowDown/ArrowUp: move focus through results (roving tabindex pattern from RESEARCH.md Pattern 5)
    - Enter: open selected atom (call `setSelectedAtomId(result.id)` and close overlay)
    - Escape: close overlay
    - Tab: move from input to filter chips to results

    Interaction logging (data foundation per CONTEXT.md):
    - On search execution: `sendCommand({ type: 'LOG_INTERACTION', payload: { type: 'search', query, ts: Date.now() } })`
    - On result click: `sendCommand({ type: 'LOG_INTERACTION', payload: { type: 'click', atomId, query, ts: Date.now() } })`
    - On filter change: `sendCommand({ type: 'LOG_INTERACTION', payload: { type: 'filter', filters: activeFilters, ts: Date.now() } })`

    MiniSearch index management:
    - Use `createEffect` in the search overlay (or at app level) that watches `state.atoms.length` and calls `rebuildIndex(state.atoms)` when it changes
    - Alternatively, rebuild index once on overlay open and keep it in sync. Prefer the createEffect approach at app level (inside SearchOverlay or a dedicated signal file) so the index is always ready.

    Embedding worker lifecycle:
    - Create worker instance lazily on first search overlay open: `new Worker(new URL('../search/embedding-worker.ts', import.meta.url), { type: 'module' })`
    - Send EMBED_ATOMS on first open to pre-compute atom embeddings (cached in memory)
    - Store atom vectors in a Map<string, number[]> on the main thread (sent back from worker)
    - On query, embed the query text and compute cosine similarity against stored vectors
    - If worker not ready, show text-only results (graceful degradation — never block search)

    **CSS:**
    - `.search-overlay-backdrop`: fixed full-screen, z-index high (above detail panel)
    - `.search-overlay-container`: centered, 600px wide, rounded corners, dark bg
    - `.search-input`: full width, large font, no border, focus ring
    - `.search-filter-chips`: horizontal row, small toggleable chips
    - `.search-result-item`: compact row with type icon, title, score indicator
    - `.search-result-item.focused`: highlighted background
    - Follow existing dark theme
  </action>
  <verify>
    Run `npx tsc --noEmit`. Verify `scripts/download-model.cjs` exists and runs without error (`node scripts/download-model.cjs`). Verify `public/models/Xenova/all-MiniLM-L6-v2/` contains model files. Start dev server, press Ctrl+K — verify search overlay opens. Type a query — verify results appear with type-ahead. Click a result — verify atom detail opens. Toggle filter chips — verify results update. Press Escape — verify overlay closes. Check console for embedding worker messages (MODEL_LOADING, MODEL_READY). Verify NO network calls to HuggingFace CDN in DevTools Network tab. Verify search still works if embedding worker fails to load (graceful degradation).
  </verify>
  <done>
    MiniSearch indexes all atoms on state change. Search overlay opens via Ctrl+K with instant type-ahead results. Results are ranked by blended score (text + semantic + graph + priority). Filter chips narrow results by type, status, date range. Embedding worker lazy-loads locally-bundled ONNX model (zero network calls) for semantic search with graceful fallback. ONNX model files served from public/models/ via postinstall script. Interaction events logged for future learning. Keyboard navigation (arrow keys) works in result list.
  </done>
</task>

<task type="auto">
  <name>Task 2: Command palette + keyboard navigation + shortcut reference + overlay management</name>
  <files>
    src/ui/components/CommandPalette.tsx
    src/ui/components/ShortcutReference.tsx
    src/ui/hooks/useRovingTabindex.ts
    src/app.tsx
  </files>
  <action>
    **1. Create `src/ui/components/CommandPalette.tsx`:**

    A command palette (separate from search per CONTEXT.md) listing all available actions.

    Props: `{ onClose: () => void }`

    Structure:
    - **Backdrop**: semi-transparent overlay
    - **Palette container**: Centered, 500px wide, max-height 60vh
    - **Input**: Auto-focused, placeholder "Type a command..."
    - **Command list**: Filterable list of commands with fuzzy matching

    Command definitions (static array):
    ```typescript
    interface PaletteCommand {
      id: string;
      label: string;
      shortcut?: string;
      category: 'navigation' | 'action' | 'recent';
      action: () => void;
    }
    ```

    Commands to include:
    - **Navigation**: Go to Today (set activePage to 'today'), Go to This Week, Go to Active Projects, Go to Waiting, Go to Insights, Go to Inbox, Go to All Items, Go to Review
    - **Actions**: New Capture (open capture overlay), Undo (send UNDO command), Export Data (send EXPORT_DATA), Request Persistence, Search (open search overlay)
    - **Recent atoms**: Last 5 atoms from `state.atoms` sorted by updated_at desc — clicking navigates to atom detail

    Fuzzy filtering:
    - Filter commands by fuzzy matching on label: split query into words, check if each word appears as a substring in the label (case-insensitive). Simple approach, not MiniSearch (overkill for ~20 commands).

    Keyboard navigation:
    - ArrowDown/ArrowUp: roving tabindex through filtered results
    - Enter: execute selected command and close palette
    - Escape: close palette

    **2. Create `src/ui/components/ShortcutReference.tsx`:**

    A reference sheet showing all keyboard shortcuts.

    Props: `{ onClose: () => void }`

    Structure:
    - Modal/overlay with backdrop
    - Title: "Keyboard Shortcuts"
    - Grid layout of shortcut categories:

    | Category | Shortcut | Action |
    |----------|----------|--------|
    | Global | Ctrl/Cmd + N | Quick capture |
    | Global | Ctrl/Cmd + K | Search |
    | Global | Ctrl/Cmd + P | Command palette |
    | Global | Ctrl/Cmd + Z | Undo |
    | Global | ? | Shortcut reference |
    | Global | Escape | Close overlay/panel |
    | Navigation | 1-5 | Switch to page 1-5 |
    | Lists | Arrow Up/Down | Navigate items |
    | Lists | Enter | Open selected item |
    | Search | Arrow Up/Down | Navigate results |
    | Search | Enter | Open selected result |
    | Detail | Escape | Close detail panel |

    Render each shortcut as: `<kbd>` tag for the key combo + description text.

    **3. Create `src/ui/hooks/useRovingTabindex.ts`:**

    A shared utility hook implementing the roving tabindex pattern (RESEARCH.md Pattern 5) for keyboard navigation in any list of items. This is consumed by SearchOverlay (Task 1), CommandPalette (above), and all page atom lists (Plan 02 pages).

    ```typescript
    import { createSignal, onCleanup } from 'solid-js';

    interface UseRovingTabindexOptions {
      /** Total number of items in the list */
      itemCount: () => number;
      /** Called when Enter is pressed on the focused item */
      onSelect: (index: number) => void;
      /** Called when Escape is pressed (optional) */
      onEscape?: () => void;
      /** Whether the hook is active (default: true). Set false when an overlay is open. */
      enabled?: () => boolean;
    }

    interface UseRovingTabindexReturn {
      /** Currently focused index (-1 = none focused) */
      focusedIndex: () => number;
      /** Set focused index programmatically */
      setFocusedIndex: (index: number) => void;
      /** Props to spread on the list container div */
      containerProps: {
        role: string;
        tabindex: number;
        onKeyDown: (e: KeyboardEvent) => void;
      };
      /** Returns tabindex value for a given item index */
      itemTabindex: (index: number) => 0 | -1;
      /** Returns true if the given index is focused */
      isItemFocused: (index: number) => boolean;
    }
    ```

    Export `useRovingTabindex(options: UseRovingTabindexOptions): UseRovingTabindexReturn`:
    - `createSignal<number>(-1)` for focusedIndex
    - `containerProps.onKeyDown` handler:
      - ArrowDown: increment focusedIndex (wrap to 0 at end)
      - ArrowUp: decrement focusedIndex (wrap to last at beginning)
      - Enter: call `onSelect(focusedIndex())`
      - Escape: call `onEscape?.()` if provided
      - Home: focus first item
      - End: focus last item
    - Respect `enabled()` — if false, don't handle keydown events
    - Reset focusedIndex to -1 when itemCount changes (list re-renders)
    - `itemTabindex(i)`: returns `0` if `i === focusedIndex()`, `-1` otherwise
    - `isItemFocused(i)`: returns `true` if `i === focusedIndex()`

    This hook is used in SearchOverlay and CommandPalette (replace their inline keyboard navigation logic with this hook), AND in page components. Each page component wraps its `<For each={atoms()}>` in a container div that spreads `containerProps`, and each AtomCard receives `tabindex={itemTabindex(index)}` and `class:focused={isItemFocused(index)}`.

    **Usage in page components (Plan 02):**
    ```tsx
    // Example: TodayPage.tsx
    const { containerProps, itemTabindex, isItemFocused } = useRovingTabindex({
      itemCount: () => filteredAtoms().length,
      onSelect: (i) => setSelectedAtomId(filteredAtoms()[i].id),
      enabled: () => overlay() === 'none', // only active when no overlay
    });

    return (
      <div {...containerProps} class="atom-list">
        <For each={filteredAtoms()}>
          {(atom, i) => (
            <AtomCard
              atom={atom}
              tabindex={itemTabindex(i())}
              focused={isItemFocused(i())}
              onClick={() => setSelectedAtomId(atom.id)}
            />
          )}
        </For>
      </div>
    );
    ```

    **4. Update `src/app.tsx`:**

    Replace the current `showCapture` signal with a unified overlay state:

    ```typescript
    type OverlayState = 'none' | 'capture' | 'search' | 'command-palette' | 'shortcuts';
    const [overlay, setOverlay] = createSignal<OverlayState>('none');
    ```

    Update the handleKeyDown function:

    - `Ctrl+N / Cmd+N`: `setOverlay(overlay() === 'capture' ? 'none' : 'capture')` (toggle)
    - `Ctrl+K / Cmd+K`: `setOverlay('search')` — always opens search (CONTEXT.md: separate from command palette)
    - `Ctrl+P / Cmd+P`: `setOverlay('command-palette')`
    - `?` key (when not in an input field): `setOverlay('shortcuts')` — check `document.activeElement?.tagName` is not INPUT/TEXTAREA/SELECT before triggering
    - `Escape`: `setOverlay('none')` (close whatever is open). Also close atom detail panel if no overlay is open: `if (overlay() === 'none') setSelectedAtomId(null)`
    - Number keys 1-5 (when not in input): Switch pages — 1=today, 2=this-week, 3=active-projects, 4=waiting, 5=insights. Call `setActivePage(pageId)`.

    Helper function `isInputFocused()`:
    ```typescript
    function isInputFocused(): boolean {
      const tag = document.activeElement?.tagName;
      return tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT';
    }
    ```

    Update the JSX:
    - Replace `<Show when={showCapture()}>` with `<Show when={overlay() === 'capture'}>`
    - Add `<Show when={overlay() === 'search'}><SearchOverlay onClose={() => setOverlay('none')} /></Show>`
    - Add `<Show when={overlay() === 'command-palette'}><CommandPalette onClose={() => setOverlay('none')} /></Show>`
    - Add `<Show when={overlay() === 'shortcuts'}><ShortcutReference onClose={() => setOverlay('none')} /></Show>`
    - Update FAB button to use `setOverlay('capture')`
    - Keep CapEnforcementModal and StorageWarning as-is (they're not part of the overlay system)

    **Keyboard navigation for atom lists (NAV-03):**
    The shared `useRovingTabindex` hook (created in step 3 above) provides a consistent keyboard navigation pattern across the entire app. It is used in:
    - SearchOverlay result list (Task 1)
    - CommandPalette command list (step 1 above)
    - All five page components (Plan 02: TodayPage, ThisWeekPage, ActiveProjectsPage, WaitingPage, InsightsPage)

    The app.tsx global handler only manages overlays and global shortcuts. Page-level keyboard nav (ArrowUp/Down through atom cards, Enter to open) is handled by each page component consuming `useRovingTabindex` on its `<For>` list container.

    **IMPORTANT per CONTEXT.md:**
    - Command palette is SEPARATE from search (different overlay, different shortcut)
    - Search is Spotlight-style (Ctrl+K)
    - Command palette lists actions + recent atoms (Ctrl+P)
    - Mobile: FAB button in bottom-right already exists for capture. Command palette mobile access via the same FAB long-press or a menu item (defer complex mobile FAB to v2; for now, command palette is keyboard-only)

    **Discoverability (CONTEXT.md):**
    - Tooltips on interactive elements should include shortcut hints (e.g., capture button title includes "(Ctrl+N)")
    - This is already partially done. Ensure new buttons/tabs include shortcut hints in `title` attributes.

    Pass `setOverlay` to CommandPalette so it can trigger the search overlay as a command action.

    **CSS:**
    - `.command-palette-backdrop`, `.command-palette-container`: similar to search overlay
    - `.command-palette-input`: full width, medium font
    - `.command-item`: row with label, shortcut badge, hover highlight
    - `.shortcut-reference-overlay`: modal with grid layout
    - `kbd`: styled key indicator (border, rounded, small padding, mono font)
  </action>
  <verify>
    Run `npx tsc --noEmit`. Start dev server. Press Ctrl+K — search opens. Press Escape, then Ctrl+P — command palette opens. Type "today" — verify "Go to Today" command appears. Press Enter — verify page switches to Today. Press ? — verify shortcut reference opens. Press 1-5 — verify page switching. Verify only one overlay can be open at a time (Ctrl+K while palette is open should switch to search).
  </verify>
  <done>
    Command palette opens via Ctrl+P with fuzzy-filterable actions (navigation, captures, recent atoms). Search overlay opens via Ctrl+K (separate from palette). Shortcut reference opens via ? key. Unified overlay state prevents stacking. Number keys 1-5 switch pages. Escape closes overlays. Arrow keys navigate within overlays. All shortcuts have tooltip hints for discoverability.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `pnpm add minisearch @huggingface/transformers` installs without errors
3. Ctrl+K opens search, type-ahead returns relevant results
4. Ctrl+P opens command palette, commands are filterable and executable
5. ? opens shortcut reference sheet
6. Escape closes any open overlay; only one overlay open at a time
7. Number keys 1-5 switch between default pages
8. Arrow keys navigate search results and command palette items
9. Search filter chips narrow results by type/status/date
10. Embedding worker loads model from local public/models/ with zero network calls; search works without embeddings (fallback to text-only)
11. No requests to HuggingFace CDN visible in DevTools Network tab
</verification>

<success_criteria>
- Full-text search returns ranked results across all atom types (NAV-01)
- Search supports inline filtering by type, status, date range (NAV-02)
- Keyboard navigation works throughout: overlays, lists, page switching (NAV-03)
- Command palette lists all actions and is accessible via Ctrl+P (NAV-04)
- Vector embeddings load from bundled local model (zero network calls per user decision), enhance ranking when available, degrade gracefully when not
- Only one overlay open at a time; Escape always closes current overlay
- Interaction events are logged for future learning
</success_criteria>

<output>
After completion, create `.planning/phases/03-pages-navigation-and-search/03-03-SUMMARY.md`
</output>
