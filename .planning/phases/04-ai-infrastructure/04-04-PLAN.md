---
phase: 04-ai-infrastructure
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app.tsx
  - src/worker/worker.ts
  - src/ui/signals/store.ts
autonomous: true
gap_closure: true
requirements: [AINF-01, AINF-05]

must_haves:
  truths:
    - "NoOpAdapter is initialized on the main thread so dispatchAICommand() has a working adapter"
    - "A user-triggerable action calls dispatchAICommand() and the round-trip completes without error"
    - "After the round-trip, aiActivity transitions from 'Processing...' to null, proving store updates work"
  artifacts:
    - path: "src/app.tsx"
      provides: "Main-thread NoOpAdapter initialization on mount"
      contains: "setActiveAdapter"
    - path: "src/ui/signals/store.ts"
      provides: "dispatchAICommand still dispatches via main-thread router"
    - path: "src/worker/worker.ts"
      provides: "Worker-side setActiveAdapter removed or commented (no functional effect, prevents confusion)"
  key_links:
    - from: "src/app.tsx"
      to: "src/ai/router.ts"
      via: "setActiveAdapter(new NoOpAdapter()) in onMount"
      pattern: "setActiveAdapter.*NoOpAdapter"
    - from: "src/ui/signals/store.ts"
      to: "src/ai/router.ts"
      via: "dispatchAICommand calls dispatchAI on main-thread router where adapter is now set"
      pattern: "dispatchAI\\("
---

<objective>
Fix the architectural split where NoOpAdapter is initialized in the BinderCore worker thread but dispatchAICommand() runs on the main thread. Since browser workers and the main thread have separate module registries, the main-thread router's activeAdapter is always null, making every dispatchAICommand() call throw "No AI adapter available". Also add a temporary dev-only test dispatch in App.tsx onMount to prove the full round-trip works end-to-end.

Purpose: Close the one remaining verification gap blocking Phase 4 completion (success criterion 3).
Output: Working no-op round-trip verifiable in browser dev console.
</objective>

<execution_context>
@C:/Users/patri/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/patri/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-ai-infrastructure/04-VERIFICATION.md
@.planning/phases/04-ai-infrastructure/04-01-SUMMARY.md
@.planning/phases/04-ai-infrastructure/04-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Move NoOpAdapter initialization to main thread and add dev-only round-trip test</name>
  <files>
    src/app.tsx
    src/worker/worker.ts
    src/ui/signals/store.ts
  </files>
  <action>
    **Problem:** `setActiveAdapter(new NoOpAdapter())` at line 199 of `src/worker/worker.ts` sets the adapter in the worker's module scope. The main-thread `dispatchAICommand()` in `store.ts` imports its own instance of `src/ai/router.ts` where `activeAdapter` is always `null`.

    **Fix 1 — Initialize NoOpAdapter on the main thread (`src/app.tsx`):**
    - Import `setActiveAdapter` from `../ai/router` and `NoOpAdapter` from `../ai/adapters/noop`
    - In the existing `onMount` callback (after `initWorker()` succeeds), call `setActiveAdapter(new NoOpAdapter())` to set the main-thread router's adapter
    - This ensures `dispatchAICommand()` in store.ts has a working adapter immediately after worker init

    **Fix 2 — Remove the worker-side NoOpAdapter init (`src/worker/worker.ts`):**
    - At line 199, replace `setActiveAdapter(new NoOpAdapter())` with a comment: `// NoOpAdapter now initialized on main thread (app.tsx) — worker module scope is separate`
    - Remove the imports of `setActiveAdapter` from `'../ai/router'` and `NoOpAdapter` from `'../ai/adapters/noop'` (lines 51-52) since they are no longer used in the worker
    - Update the file header comment at line 28 to reflect this change: remove "INIT handler: setActiveAdapter(new NoOpAdapter()) for round-trip verification"

    **Fix 3 — Add dev-only round-trip test dispatch (`src/app.tsx`):**
    - After `setActiveAdapter(new NoOpAdapter())`, add a dev-only test dispatch that proves the round-trip:
    ```ts
    // Dev-only: verify AI round-trip works (Phase 4 gap closure proof)
    if (import.meta.env.DEV) {
      dispatchAICommand('Phase 4 round-trip test').then(() => {
        console.log('[BinderOS] AI round-trip verified: NoOp adapter responded');
      }).catch((err) => {
        console.error('[BinderOS] AI round-trip FAILED:', err);
      });
    }
    ```
    - Import `dispatchAICommand` from `./ui/signals/store`
    - This fires only in dev mode (`import.meta.env.DEV`), logs success/failure to console, and provides the user-triggerable proof that the verification gap demands

    **Why this works:** After this change, the main-thread module instance of `router.ts` (the one `store.ts` imports) has `activeAdapter` set to a `NoOpAdapter`. When `dispatchAICommand()` calls `dispatchAI()`, the adapter is there and responds. Later, when Phase 5 connects the real BrowserAdapter or CloudAdapter, `setActiveAdapter()` will be called again with the real adapter, replacing the NoOpAdapter.
  </action>
  <verify>
    1. `pnpm lint` passes with 0 errors
    2. `npx tsc --noEmit` passes with 0 type errors
    3. `pnpm dev` starts, open browser console: "[BinderOS] AI round-trip verified: NoOp adapter responded" appears without errors
    4. No "No AI adapter available" error in console
  </verify>
  <done>
    The NoOpAdapter is initialized on the main thread. A dev-only test dispatch proves the full round-trip: dispatchAICommand() -> dispatchAI() -> NoOpAdapter.execute() -> store update. The "[BinderOS] AI round-trip verified" message appears in the dev console. Phase 4 success criterion 3 is satisfied.
  </done>
</task>

</tasks>

<verification>
1. **Lint:** `pnpm lint` passes — no unused imports, no errors
2. **Types:** `npx tsc --noEmit` passes — all type references valid
3. **Round-trip proof:** `pnpm dev` -> open browser -> dev console shows "[BinderOS] AI round-trip verified: NoOp adapter responded"
4. **No regression:** Worker still initializes normally (WASM scoring, periodic re-scoring still work)
5. **Production clean:** `pnpm build` succeeds — dev-only dispatch is tree-shaken out by Vite
</verification>

<success_criteria>
- dispatchAICommand('Phase 4 round-trip test') completes without throwing
- Dev console shows round-trip success message
- No "No AI adapter available" error at any point
- pnpm lint, tsc --noEmit, pnpm build all pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-ai-infrastructure/04-04-SUMMARY.md`
</output>
