---
phase: 05-triage-ai
plan: 03
type: execute
wave: 2
depends_on: ["05-02"]
files_modified:
  - src/ai/triage.ts
  - src/ai/similarity.ts
  - src/ui/signals/store.ts
autonomous: true
requirements: [AITG-01, AITG-02, AITG-03, AITG-04, AITG-05, AIUX-06]

must_haves:
  truths:
    - "AI suggests an atom type (task/fact/event/decision/insight) for each inbox item based on content analysis"
    - "AI suggests a section/project for each inbox item based on existing section item patterns"
    - "AI reasoning is included with each suggestion explaining why that type/section was chosen"
    - "Entropy signals (staleness, priority tier, system entropy level) are included in the triage prompt"
    - "2-3 semantically related atoms are surfaced alongside each suggestion"
    - "Triage processes inbox items sequentially with AbortController cancellation support"
    - "Partial results are preserved when the user cancels mid-stream"
    - "Triage suggestion state is ephemeral (SolidJS signal Map), NOT in BinderState or Dexie"
  artifacts:
    - path: "src/ai/triage.ts"
      provides: "Batch triage pipeline with prompt builder, response parser, and sequential processing"
      exports: ["triageInbox", "cancelTriage", "buildTriagePrompt", "parseTriageResponse", "TriageSuggestion"]
      min_lines: 100
    - path: "src/ai/similarity.ts"
      provides: "Keyword similarity for finding related atoms, extracted from classification-log.ts pattern"
      exports: ["findRelatedAtoms"]
      min_lines: 20
    - path: "src/ui/signals/store.ts"
      provides: "Triage suggestion Map signal and triageStatus signal exported separately from BinderState"
      contains: "triageSuggestions"
  key_links:
    - from: "src/ai/triage.ts"
      to: "src/ai/router.ts"
      via: "calls dispatchAI() for each inbox item"
      pattern: "dispatchAI"
    - from: "src/ai/triage.ts"
      to: "src/ai/similarity.ts"
      via: "calls findRelatedAtoms() per item for AITG-04"
      pattern: "findRelatedAtoms"
    - from: "src/ai/triage.ts"
      to: "src/ui/signals/store.ts"
      via: "reads state.scores, state.entropyScore, state.sectionItems for prompt context"
      pattern: "state\\.scores|state\\.entropyScore"
---

<objective>
Build the AI triage pipeline — the batch processing engine that analyzes inbox items, produces type/section suggestions with reasoning, and manages triage state.

Purpose: This is the core AI triage intelligence (AITG-01 through AITG-05). Each inbox item gets a structured AI suggestion with type, section, reasoning, confidence, and related atoms. The pipeline uses sequential processing with AbortController cancellation (AIUX-06).

Output: src/ai/triage.ts (pipeline), src/ai/similarity.ts (related atoms), triage signal state in store.ts.
</objective>

<execution_context>
@C:/Users/patri/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/patri/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-triage-ai/05-RESEARCH.md
@.planning/phases/05-triage-ai/05-02-SUMMARY.md
@src/ai/router.ts
@src/ai/adapters/adapter.ts
@src/ai/privacy-proxy.ts
@src/storage/classification-log.ts
@src/ui/signals/store.ts
@src/types/atoms.ts
@src/types/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create similarity module and triage pipeline with prompt builder and response parser</name>
  <files>src/ai/similarity.ts, src/ai/triage.ts</files>
  <action>
**1. Create src/ai/similarity.ts:**
Extract the keyword similarity logic from `src/storage/classification-log.ts` into a reusable module. The original `keywordSimilarity()` function is private to classification-log.ts, so re-implement the same logic:

```typescript
// src/ai/similarity.ts — Keyword similarity for finding related atoms (AITG-04)
// Reuses the Jaccard keyword overlap approach from classification-log.ts

const STOP_WORDS = new Set(['the', 'a', 'an', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
  'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might',
  'shall', 'can', 'to', 'of', 'in', 'for', 'on', 'with', 'at', 'by', 'from', 'as', 'into',
  'through', 'during', 'before', 'after', 'above', 'below', 'between', 'and', 'but', 'or', 'not',
  'no', 'nor', 'so', 'yet', 'this', 'that', 'these', 'those', 'it', 'its']);

function extractKeywords(text: string): string[] {
  return text.toLowerCase()
    .replace(/[^a-z0-9\s]/g, ' ')
    .split(/\s+/)
    .filter(w => w.length > 2 && !STOP_WORDS.has(w));
}

function keywordSimilarity(a: string, b: string): number {
  const kwA = new Set(extractKeywords(a));
  const kwB = new Set(extractKeywords(b));
  if (kwA.size === 0 || kwB.size === 0) return 0;
  let intersection = 0;
  for (const w of kwA) { if (kwB.has(w)) intersection++; }
  return intersection / (kwA.size + kwB.size - intersection); // Jaccard
}
```

Export `findRelatedAtoms(content: string, atoms: Array<{ id: string; title?: string; content: string }>, limit?: number): string[]`:
- Scores each atom by `keywordSimilarity(content, atom.content + ' ' + (atom.title ?? ''))`
- Filters scores > 0.15 threshold
- Returns top `limit` (default 3) atom IDs sorted by score descending

Do NOT import from store.ts here — keep this module pure. The caller passes atoms in.

**2. Create src/ai/triage.ts:**

Define the `TriageSuggestion` interface:
```typescript
export interface TriageSuggestion {
  inboxItemId: string;
  suggestedType: AtomType;
  suggestedSectionItemId: string | null;
  reasoning: string;
  confidence: 'high' | 'low';
  relatedAtomIds: string[];
  status: 'pending' | 'complete' | 'error';
  errorMessage?: string;
}
```

Import types from: `../types/atoms` (AtomType, InboxItem), `../types/config` (AtomScore, EntropyScore), `../types/sections` (SectionItem, Section).

**buildTriagePrompt function:**
Build a structured prompt per RESEARCH.md Pattern 4. Include:
- Inbox item title and content
- Atom type definitions (task, fact, event, decision, insight) with brief descriptions
- Available section items with their names and parent section names
- Entropy context: system entropy level/score, stale count, open tasks count (AITG-03)
- Per-item score context: staleness, priorityTier if available (AITG-03)
- Instruction to respond with ONLY valid JSON: `{"type":"<atom_type>","sectionItemId":"<id_or_null>","reasoning":"<one sentence why>","confidence":"<high_or_low>"}`

Use `sanitizeForCloud()` from `../ai/privacy-proxy` if the active adapter is cloud. For browser LLM, send content directly (it stays on device).

**parseTriageResponse function:**
- Extract JSON from response using regex `responseText.match(/\{[\s\S]*\}/)`
- Parse with `JSON.parse`, validate type is one of the valid AtomTypes
- Return a `TriageSuggestion` with status 'complete', or null on parse failure
- On null, the caller should set status to 'error' with a message

**triageInbox function:**
```typescript
export async function triageInbox(
  inboxItems: InboxItem[],
  scores: Record<string, AtomScore>,
  entropyScore: EntropyScore | null,
  sectionItems: SectionItem[],
  sections: Section[],
  atoms: Array<{ id: string; title?: string; content: string }>,
  onSuggestion: (suggestion: TriageSuggestion) => void,
  onError: (itemId: string, error: string) => void,
): Promise<void>
```

Implementation:
- Cancel any previous in-flight triage: `triageAbortController?.abort()`
- Create new `AbortController`
- Build section list with names resolved from sections
- Process items **sequentially** (one at a time) to avoid rate limits (RESEARCH.md Pitfall 3)
- For each item:
  - Check `signal.aborted` — if true, break (preserves completed suggestions per CONTEXT.md)
  - Build prompt via `buildTriagePrompt()`
  - Find related atoms via `findRelatedAtoms(item.content + ' ' + (item.title ?? ''), atoms)`
  - Call `dispatchAI({ requestId: crypto.randomUUID(), prompt, maxTokens: 200 })` from `../ai/router`
  - Parse response, call `onSuggestion` with result (or error status if parse fails)
  - On catch: if not aborted, call `onError` with the error message

**cancelTriage function:**
Aborts the current AbortController and sets it to null.

Note: The `dispatchAI` call from `src/ai/router.ts` already exists and works from the main thread (established in Phase 4 Plan 02/04). The triage pipeline runs on the main thread where the adapters live. Do NOT try to dispatch from the worker.

**IMPORTANT per RESEARCH.md:** Do NOT use `dispatchAI`'s `onChunk` callback for card-by-card display. Each card gets its full suggestion only when `parseTriageResponse` returns a valid result. No per-token animation on cards (CONTEXT.md decision).
  </action>
  <verify>
- `npx tsc --noEmit` compiles
- `pnpm lint` passes
- src/ai/triage.ts exports `triageInbox`, `cancelTriage`, `buildTriagePrompt`, `parseTriageResponse`, `TriageSuggestion`
- src/ai/similarity.ts exports `findRelatedAtoms`
- No imports from store.ts in triage.ts or similarity.ts (pure modules)
  </verify>
  <done>
Triage pipeline processes inbox items sequentially through AI with structured prompts including entropy signals, parses JSON responses for type/section/reasoning/confidence, finds related atoms via keyword similarity, and supports AbortController cancellation with partial result preservation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add triage store signals and orchestration function</name>
  <files>src/ui/signals/store.ts</files>
  <action>
**Add triage state signals to store.ts as module-level signals (NOT in BinderState):**

Per RESEARCH.md Pitfall 1, triage suggestions are ephemeral main-thread state. They MUST NOT be part of `BinderState` (which reconciles from worker messages). Create separate module-level signals:

```typescript
// Phase 5: Triage suggestion state (ephemeral, main-thread only)
// NOT part of BinderState — worker reconcile must not touch these

import { createSignal } from 'solid-js';
import type { TriageSuggestion } from '../../ai/triage';

type TriageStatus = 'idle' | 'running' | 'complete' | 'error' | 'cancelled';

const [triageSuggestions, setTriageSuggestions] = createSignal<Map<string, TriageSuggestion>>(new Map());
const [triageStatus, setTriageStatus] = createSignal<TriageStatus>('idle');
const [triageError, setTriageError] = createSignal<string | null>(null);

export { triageSuggestions, triageStatus, triageError };
```

**Create `startTriageInbox()` orchestration function in store.ts:**

This function bridges the pure triage pipeline to the store's reactive signals:

```typescript
import { triageInbox, cancelTriage } from '../../ai/triage';
import { setOrbState } from '../components/AIOrb'; // from Plan 01

export async function startTriageInbox(): Promise<void> {
  // Guard: only run if AI is available and triage is enabled
  if (!anyAIAvailable() || !state.triageEnabled) return;
  if (state.inboxItems.length === 0) return;
  if (triageStatus() === 'running') {
    cancelTriage();
    return; // cancel existing, will be set to 'cancelled' below
  }

  setTriageStatus('running');
  setTriageError(null);
  setTriageSuggestions(new Map());
  setOrbState('thinking');

  const atoms = state.atoms.map(a => ({ id: a.id, title: a.title, content: a.content }));

  try {
    await triageInbox(
      state.inboxItems,
      state.scores,
      state.entropyScore,
      state.sectionItems,
      state.sections,
      atoms,
      (suggestion) => {
        // Each suggestion completes — update the Map reactively
        setOrbState('streaming');
        setTriageSuggestions(prev => {
          const next = new Map(prev);
          next.set(suggestion.inboxItemId, suggestion);
          return next;
        });
      },
      (itemId, error) => {
        // Individual item error — set error status on that item
        setTriageSuggestions(prev => {
          const next = new Map(prev);
          next.set(itemId, {
            inboxItemId: itemId,
            suggestedType: 'fact',
            suggestedSectionItemId: null,
            reasoning: '',
            confidence: 'low',
            relatedAtomIds: [],
            status: 'error',
            errorMessage: error,
          });
          return next;
        });
      },
    );
    setTriageStatus('complete');
    setOrbState('idle');
  } catch (err) {
    if (err instanceof DOMException && err.name === 'AbortError') {
      setTriageStatus('cancelled');
    } else {
      setTriageStatus('error');
      setTriageError(err instanceof Error ? err.message : String(err));
    }
    setOrbState(triageStatus() === 'cancelled' ? 'idle' : 'error');
  }
}
```

**Create `acceptAISuggestion(itemId: string)` function in store.ts:**

Called when the user accepts an AI triage suggestion (Plan 04 will wire this to swipe-right):

```typescript
export function acceptAISuggestion(itemId: string): void {
  const suggestions = triageSuggestions();
  const suggestion = suggestions.get(itemId);
  if (!suggestion || suggestion.status !== 'complete') return;

  // Apply via existing mutation pipeline — same path as manual classification
  sendCommand({
    type: 'CLASSIFY_INBOX_ITEM',
    payload: {
      id: itemId,
      type: suggestion.suggestedType,
      sectionItemId: suggestion.suggestedSectionItemId ?? undefined,
      aiSourced: true, // Tag as AI-sourced (Plan 02 schema extension)
    },
  });

  // Remove from suggestion Map
  setTriageSuggestions(prev => {
    const next = new Map(prev);
    next.delete(itemId);
    return next;
  });
}
```

**Create `dismissAISuggestion(itemId: string)` function:**

```typescript
export function dismissAISuggestion(itemId: string): void {
  setTriageSuggestions(prev => {
    const next = new Map(prev);
    next.delete(itemId);
    return next;
  });
}
```

**Create `acceptAllAISuggestions()` function:**

```typescript
export function acceptAllAISuggestions(): void {
  const suggestions = triageSuggestions();
  for (const [itemId, suggestion] of suggestions) {
    if (suggestion.status === 'complete') {
      sendCommand({
        type: 'CLASSIFY_INBOX_ITEM',
        payload: {
          id: itemId,
          type: suggestion.suggestedType,
          sectionItemId: suggestion.suggestedSectionItemId ?? undefined,
          aiSourced: true,
        },
      });
    }
  }
  setTriageSuggestions(new Map());
}
```

Export all new functions and signals.
  </action>
  <verify>
- `npx tsc --noEmit` compiles
- `pnpm lint` passes
- store.ts exports: `triageSuggestions`, `triageStatus`, `triageError`, `startTriageInbox`, `acceptAISuggestion`, `dismissAISuggestion`, `acceptAllAISuggestions`
- `triageSuggestions` is a standalone signal, NOT part of BinderState
  </verify>
  <done>
Triage orchestration wired in store.ts with module-level ephemeral signals for suggestions, a startTriageInbox() function that drives the pipeline and updates orb state, and accept/dismiss/acceptAll functions for user interaction. All triage state is isolated from BinderState reconciliation.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. Lint passes without new warnings
3. Triage pipeline module is importable and types check
4. `triageSuggestions` signal is NOT part of `BinderState` interface
5. `acceptAISuggestion` sends CLASSIFY_INBOX_ITEM with `aiSourced: true`
</verification>

<success_criteria>
- AI triage prompt includes atom type definitions, section items, entropy signals, and per-item scores
- Response parser handles JSON extraction with regex + try/catch for resilient parsing
- Sequential processing prevents rate limit exhaustion
- AbortController cancellation preserves completed suggestions
- Related atoms found via Jaccard keyword similarity (no model inference needed)
- Triage state is ephemeral (SolidJS signal, not Dexie or BinderState)
</success_criteria>

<output>
After completion, create `.planning/phases/05-triage-ai/05-03-SUMMARY.md`
</output>
