---
phase: 06-review-pre-analysis
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/atoms.ts
  - src/types/messages.ts
  - src/storage/migrations/v4.ts
  - src/storage/db.ts
  - src/worker/worker.ts
  - src/ui/signals/queries.ts
  - src/ai/analysis.ts
  - src/ui/signals/store.ts
  - src/ui/components/AIOrb.tsx
  - src/ui/components/AIRadialMenu.tsx
autonomous: true
requirements:
  - AIGN-01
  - AIRV-01
  - AIRV-02

must_haves:
  truths:
    - "Analysis atoms exist as a distinct type alongside task/fact/event/decision/insight"
    - "Analysis atoms are excluded from WASM scoring and standard page queries"
    - "Tapping Review in the orb radial menu triggers a briefing generation pipeline that reads store state and dispatches a cloud AI call"
    - "The briefing pipeline emits incremental progress messages before the AI call completes"
    - "The store holds reviewBriefing, reviewStatus, and reviewProgress reactive state"
  artifacts:
    - path: "src/types/atoms.ts"
      provides: "AnalysisAtomSchema in discriminated union"
      contains: "type: z.literal('analysis')"
    - path: "src/storage/migrations/v4.ts"
      provides: "Dexie v4 migration for analysis atom type"
      contains: "db.version(4)"
    - path: "src/ai/analysis.ts"
      provides: "Briefing generation pipeline"
      exports: ["generateBriefing", "BriefingResult", "BriefingItem"]
    - path: "src/ui/signals/store.ts"
      provides: "Review state extension and startReviewBriefing orchestrator"
      contains: "startReviewBriefing"
  key_links:
    - from: "src/ai/analysis.ts"
      to: "src/ai/router.ts"
      via: "dispatchAI call for summary generation"
      pattern: "dispatchAI"
    - from: "src/ui/signals/store.ts"
      to: "src/ai/analysis.ts"
      via: "startReviewBriefing calls generateBriefing"
      pattern: "generateBriefing"
    - from: "src/ui/components/AIOrb.tsx"
      to: "src/ui/signals/store.ts"
      via: "review action calls startReviewBriefing"
      pattern: "startReviewBriefing"
---

<objective>
Add the `analysis` atom type to the schema with Dexie v4 migration, build the briefing analysis pipeline, extend the store with review state, and wire the orb's Review action to trigger briefing generation.

Purpose: Establishes the data foundation (AIGN-01) and the complete backend pipeline (AIRV-01, AIRV-02) that powers the review briefing experience. After this plan, the analysis pipeline is fully functional and can generate briefings — the UI rendering comes in Plan 02.

Output: AnalysisAtomSchema in the discriminated union, Dexie v4 migration, `src/ai/analysis.ts` pipeline module, store review state fields, and orb Review action wired to `startReviewBriefing()`.
</objective>

<execution_context>
@C:/Users/patri/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/patri/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-review-pre-analysis/06-CONTEXT.md
@.planning/phases/06-review-pre-analysis/06-RESEARCH.md
@.planning/phases/05-triage-ai/05-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Analysis atom type schema + Dexie v4 migration + WASM/query exclusion</name>
  <files>
    src/types/atoms.ts
    src/types/messages.ts
    src/storage/migrations/v4.ts
    src/storage/db.ts
    src/worker/worker.ts
    src/ui/signals/queries.ts
  </files>
  <action>
**1. Extend AtomType and add AnalysisAtomSchema (`src/types/atoms.ts`):**

Add `'analysis'` to the `AtomType` z.enum:
```typescript
export const AtomType = z.enum([
  'task', 'fact', 'event', 'decision', 'insight', 'analysis',
]);
```

Add `AnalysisAtomSchema` after `InsightAtomSchema`:
```typescript
export const AnalysisAtomSchema = z.object({
  ...BaseAtomFields,
  type: z.literal('analysis'),
  analysisKind: z.enum(['review-briefing', 'trend-insight', 'relationship-map']),
  isReadOnly: z.literal(true),
  briefingData: z.object({
    summaryText: z.string(),
    staleItems: z.array(z.object({ atomId: z.string(), title: z.string(), staleDays: z.number().optional(), linkCount: z.number().optional(), entropyScore: z.number().optional() })),
    projectsMissingNextAction: z.array(z.object({ atomId: z.string(), title: z.string() })),
    compressionCandidates: z.array(z.object({ atomId: z.string(), title: z.string(), staleDays: z.number().optional() })),
    generatedAt: z.number(),
  }).optional(),
});
export type AnalysisAtom = z.infer<typeof AnalysisAtomSchema>;
```

Add `AnalysisAtomSchema` to the `AtomSchema` discriminated union:
```typescript
export const AtomSchema = z.discriminatedUnion('type', [
  TaskAtomSchema, FactAtomSchema, EventAtomSchema, DecisionAtomSchema, InsightAtomSchema, AnalysisAtomSchema,
]);
```

Add `AnalysisAtomSchema` to the `CreateAtomInputSchema` discriminated union (omitting id/timestamps):
```typescript
export const CreateAtomInputSchema = z.discriminatedUnion('type', [
  TaskAtomSchema.omit({ id: true, created_at: true, updated_at: true }),
  // ... existing ...
  AnalysisAtomSchema.omit({ id: true, created_at: true, updated_at: true }),
]);
```

**2. Update messages.ts (`src/types/messages.ts`):**

No new Command types needed for Phase 6 — analysis atoms are created via existing `CREATE_ATOM` command. However, extend the READY response payload to include `reviewSession`:
```typescript
// In the READY response payload type, add:
reviewSession?: import('../storage/review-session').ReviewSession | null;
```
Note: The ReviewSession type will be created in Plan 02. For now, add the field as `reviewSession?: unknown;` and leave a Phase 6 Plan 02 comment.

**3. Create Dexie v4 migration (`src/storage/migrations/v4.ts`):**

Follow the exact pattern of v3.ts. Create `applyV4Migration(db: BinderDB)` that:
- Calls `db.version(4).stores({...})` with ALL table index strings (copy from v3, no changes to index strings — the `type` index on atoms already covers 'analysis')
- No upgrade() callback needed — new analysis atoms will be created with correct fields from the start. Existing atoms don't need migration.

```typescript
import type { BinderDB } from '../db';

export function applyV4Migration(db: BinderDB): void {
  db.version(4).stores({
    atoms:        '&id, type, status, sectionId, sectionItemId, updated_at, *links, *tags, context, aiSourced',
    inbox:        '&id, created_at',
    changelog:    '&id, atomId, timestamp, lamportClock',
    sections:     '&id, type',
    sectionItems: '&id, sectionId, name, archived',
    config:       '&key',
    savedFilters: '&id, name',
    interactions: '&id, type, ts',
  });
}
```

**4. Register v4 migration in db.ts (`src/storage/db.ts`):**

Import `applyV4Migration` and call it after `applyV3Migration(this)` in the BinderDB constructor:
```typescript
import { applyV4Migration } from './migrations/v4';
// ... in constructor after applyV3Migration(this):
applyV4Migration(this);
```

**5. Exclude analysis atoms from WASM scoring (`src/worker/worker.ts`):**

In `flattenAtomLinksForWasm()`, filter out analysis atoms before mapping:
```typescript
function flattenAtomLinksForWasm(atoms: Atom[]): unknown[] {
  return atoms
    .filter((atom) => atom.type !== 'analysis')
    .map((atom) => ({
      // ... existing mapping
    }));
}
```

Also in `getFullState()`, no change needed — analysis atoms should be in the state snapshot so ReviewBriefingView can render them. The filtering happens at the WASM scoring boundary only.

**6. Filter analysis atoms from page queries (`src/ui/signals/queries.ts`):**

In every page query memo (todayAtoms, thisWeekAtoms, activeProjectAtoms, waitingAtoms, insightAtoms), add `a.type !== 'analysis'` to the filter chain. Also add the filter to `filteredAndSortedAtoms()` so saved filter views exclude analysis atoms.

For each query, add the filter as the FIRST predicate in the chain:
```typescript
// Example for todayAtoms:
.filter((a) => a.type !== 'analysis' && /* existing conditions */)
```

For `filteredAndSortedAtoms`, add before the type filter:
```typescript
result = result.filter((a) => a.type !== 'analysis');
```
  </action>
  <verify>
- `npx tsc --noEmit` passes (type checking confirms AnalysisAtomSchema is in union)
- Grep `analysis` in atoms.ts confirms type literal, schema, and union membership
- Grep `type !== 'analysis'` in queries.ts and worker.ts confirms exclusion filters
- v4.ts exists and is registered in db.ts constructor
  </verify>
  <done>
- AnalysisAtomSchema is a member of both AtomSchema and CreateAtomInputSchema discriminated unions
- Dexie v4 migration registered and will run on next app load
- WASM scoring excludes analysis atoms via filter in flattenAtomLinksForWasm
- All 5 page query memos and filteredAndSortedAtoms exclude analysis atoms
- READY payload type has reviewSession field (typed as unknown for Plan 02)
  </done>
</task>

<task type="auto">
  <name>Task 2: Analysis pipeline module + store review state + orb Review action wiring</name>
  <files>
    src/ai/analysis.ts
    src/ui/signals/store.ts
    src/ui/components/AIOrb.tsx
    src/ui/components/AIRadialMenu.tsx
  </files>
  <action>
**1. Create the analysis pipeline module (`src/ai/analysis.ts`):**

Follow the triage.ts pure-module pattern exactly: no imports from store.ts, all state passed in by caller, AbortController for cancellation.

```typescript
/**
 * AI review pre-analysis pipeline — generates briefing from store state (AIRV-01, AIRV-02).
 *
 * Two-phase architecture:
 * 1. Pre-analysis (synchronous, no AI): compute stale items, projects without next actions,
 *    compression candidates from store data. Emit progress via onProgress callback.
 * 2. AI summary call: pass pre-computed stats to cloud adapter for a single summary sentence.
 *
 * Pure module: no imports from store.ts. All state passed in by caller.
 * Mirrors src/ai/triage.ts pattern.
 */
```

Export interfaces:
```typescript
export interface BriefingItem {
  atomId: string;
  title: string;
  staleDays?: number;
  linkCount?: number;
  entropyScore?: number;
}

export interface BriefingResult {
  summaryText: string;
  staleItems: BriefingItem[];
  projectsMissingNextAction: BriefingItem[];
  compressionCandidates: BriefingItem[];
  generatedAt: number;
}
```

Export the main function:
```typescript
export async function generateBriefing(
  atoms: Atom[],
  scores: Record<string, AtomScore>,
  entropyScore: EntropyScore | null,
  sectionItems: SectionItem[],
  sections: Section[],
  onProgress: (message: string) => void,
  signal?: AbortSignal,
): Promise<BriefingResult>
```

Implementation details for `generateBriefing`:

**Phase 1 — Pre-analysis (synchronous, no AI):**

a) Compute stale items: Filter atoms where `type !== 'analysis'` and `status` is `'open'` or `'in-progress'`. For each, compute staleDays = `Math.floor((Date.now() - atom.updated_at) / 86400000)`. Filter where staleDays > 14 (2 weeks). Sort descending by staleDays. Map to BriefingItem with atomId, title (from `atom.title` or `atom.content.split('\n')[0]`), staleDays, linkCount (`atom.links.length`), entropyScore (from `scores[atom.id]?.score`). Emit progress: `onProgress(\`${staleItems.length} stale item${staleItems.length === 1 ? '' : 's'} found\`)`.

b) Compute projects without next actions: Iterate `sectionItems` where `!si.archived`. For each, check if any atom with `sectionItemId === si.id` has type `'task'` and status `'open'` or `'in-progress'`. If no such atom exists, include in list. Map to BriefingItem with atomId = si.id, title = si.name. Emit progress: `onProgress(\`${projectsMissing.length} project${projectsMissing.length === 1 ? '' : 's'} missing next actions\`)`.

c) Compute compression candidates: Filter atoms where `type !== 'analysis'` and `status !== 'archived'` and `status !== 'cancelled'`. Identify candidates based on: staleDays > 30 AND linkCount === 0 (orphaned + stale). Map to BriefingItem. Emit progress: `onProgress(\`${candidates.length} compression candidate${candidates.length === 1 ? '' : 's'} identified\`)`.

**Phase 2 — AI summary sentence:**

Build a single prompt with the pre-computed statistics:
```
You are analyzing a personal knowledge management system. Based on these statistics, write ONE natural language sentence (max 30 words) summarizing the overall system health:

- Total atoms: {count}
- System entropy: {entropyScore?.level ?? 'unknown'} ({entropyScore?.score ?? 'N/A'})
- Stale items (>14 days): {staleItems.length}
- Projects without next actions: {projectsMissing.length}
- Compression candidates: {candidates.length}
- Open tasks: {openTaskCount}

Respond with ONLY the summary sentence. No JSON, no markdown, no explanation.
```

Check signal before AI call: `if (signal?.aborted) throw new DOMException('Aborted', 'AbortError');`

Call `dispatchAI({ requestId: crypto.randomUUID(), prompt, maxTokens: 100, signal })`. Parse the response as plain text (not JSON). Trim whitespace.

If the AI call fails or is aborted, use a fallback summary: `"System has {staleCount} stale items, {projectsMissing} projects needing action, and {candidates} compression candidates."`.

Return `BriefingResult` with summaryText, all three lists, and `generatedAt: Date.now()`.

**2. Extend store with review state (`src/ui/signals/store.ts`):**

Add to BinderState interface (after the Phase 4 fields):
```typescript
// Phase 6: Review pre-analysis state
reviewBriefing: BriefingResult | null;
reviewStatus: 'idle' | 'analyzing' | 'ready' | 'error';
reviewProgress: string | null;
reviewError: string | null;
```

Add defaults to initialState:
```typescript
reviewBriefing: null,
reviewStatus: 'idle',
reviewProgress: null,
reviewError: null,
```

Add module-level abort signal (same pattern as triage):
```typescript
let reviewAbortController: AbortController | null = null;
```

Create the `startReviewBriefing` orchestrator function following `startTriageInbox` pattern exactly:
```typescript
export async function startReviewBriefing(): Promise<void> {
  // 1. Guard: AI must be available (cloudReady preferably)
  if (!anyAIAvailable()) {
    setState('reviewError', 'No AI adapter available');
    setState('reviewStatus', 'error');
    return;
  }

  // 2. Cancel any in-progress briefing
  if (reviewAbortController) {
    reviewAbortController.abort();
  }
  reviewAbortController = new AbortController();

  // 3. Set orb state to 'thinking' (dynamic import to avoid circular dep)
  const { setOrbState } = await import('../components/AIOrb');
  setOrbState('thinking');

  // 4. Set review state
  setState('reviewStatus', 'analyzing');
  setState('reviewProgress', 'Analyzing system entropy...');
  setState('reviewError', null);
  setState('reviewBriefing', null);

  try {
    // 5. Import and call analysis pipeline
    const { generateBriefing } = await import('../../ai/analysis');
    const result = await generateBriefing(
      state.atoms,
      state.scores,
      state.entropyScore,
      state.sectionItems,
      state.sections,
      (msg) => setState('reviewProgress', msg),
      reviewAbortController.signal,
    );

    // 6. Store result
    setState('reviewBriefing', result);
    setState('reviewStatus', 'ready');
    setState('reviewProgress', null);

    // 7. Create analysis atom via worker command
    sendCommand({
      type: 'CREATE_ATOM',
      payload: {
        type: 'analysis',
        analysisKind: 'review-briefing',
        isReadOnly: true,
        title: `Review Briefing — ${new Date().toLocaleDateString()}`,
        content: result.summaryText,
        status: 'open',
        links: [],
        tags: [],
        aiSourced: true,
        briefingData: result,
      },
    });

    // 8. Navigate to review page
    setActivePage('review');
    setOrbState('idle');

  } catch (err) {
    if (err instanceof DOMException && err.name === 'AbortError') {
      setState('reviewStatus', 'idle');
      setState('reviewProgress', null);
    } else {
      setState('reviewStatus', 'error');
      setState('reviewError', err instanceof Error ? err.message : 'Briefing failed');
    }
    const { setOrbState: setOrb } = await import('../components/AIOrb');
    setOrb(err instanceof DOMException ? 'idle' : 'error');
  } finally {
    reviewAbortController = null;
  }
}

export function cancelReviewBriefing(): void {
  if (reviewAbortController) {
    reviewAbortController.abort();
    reviewAbortController = null;
  }
}
```

Export `startReviewBriefing` and `cancelReviewBriefing`.

**3. Wire orb Review action (`src/ui/components/AIOrb.tsx`):**

Import `startReviewBriefing` from store.ts (same as startTriageInbox is imported).

In `handleMenuAction`, add the `'review'` case:
```typescript
if (action === 'review') {
  setOrbState('idle');
  startReviewBriefing();
  return;
}
```

**4. Update AIRadialMenu label (`src/ui/components/AIRadialMenu.tsx`):**

No code changes needed — the 'review' action with label 'Review' already exists. The `handleMenuAction` in AIOrb.tsx now handles it. The label will change to 'Resume review' in Plan 02 when session state is available.
  </action>
  <verify>
- `npx tsc --noEmit` passes
- Grep `generateBriefing` in analysis.ts confirms export
- Grep `startReviewBriefing` in store.ts confirms export
- Grep `action === 'review'` in AIOrb.tsx confirms wiring
- Grep `dispatchAI` in analysis.ts confirms AI call integration
  </verify>
  <done>
- `src/ai/analysis.ts` exports generateBriefing with two-phase architecture (sync pre-analysis + AI summary)
- Store has reviewBriefing, reviewStatus, reviewProgress, reviewError fields
- startReviewBriefing() orchestrates the full pipeline with AbortController cancellation
- Analysis atom created via CREATE_ATOM after successful briefing
- Orb 'review' radial action triggers startReviewBriefing and navigates to review page
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes (`npx tsc --noEmit`)
2. AnalysisAtomSchema is in the AtomSchema discriminated union
3. Dexie v4 migration is registered and runs without error
4. WASM scoring excludes analysis atoms
5. All page queries exclude analysis atoms
6. `generateBriefing()` computes stale items, projects without next actions, and compression candidates from store data
7. `startReviewBriefing()` orchestrates pipeline: sets orb thinking, emits progress, calls AI, creates analysis atom, navigates to review
8. Orb Review action triggers the pipeline
</verification>

<success_criteria>
- Analysis atom type fully integrated into schema, migration, and scoring pipeline
- Briefing generation pipeline functional end-to-end (sync pre-analysis + AI summary)
- Store review state reactive and ready for UI consumption in Plan 02
- Orb Review action wired — tapping triggers briefing generation
</success_criteria>

<output>
After completion, create `.planning/phases/06-review-pre-analysis/06-01-SUMMARY.md`
</output>
